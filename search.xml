<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LEECODE452用最少数量的箭射爆气球</title>
      <link href="/2024/12/01/%E5%8A%9B%E6%89%A3/LEECODE452%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%B0%84%E7%88%86%E6%B0%94%E7%90%83/"/>
      <url>/2024/12/01/%E5%8A%9B%E6%89%A3/LEECODE452%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%B0%84%E7%88%86%E6%B0%94%E7%90%83/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/./../../images/%E9%A2%98%E7%9B%AE%E5%9B%BE/LE452.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>目标：要求使用最少的箭射爆所有气球</p><p>分析：题目给出了所有气球的直接范围，自然而然想到如果两个气球直径范围有重叠，那么一支箭就够用</p><p><img src="/./../../images/%E6%80%9D%E8%B7%AF/LE435.png"></p><p>以题例作图：我们可以不断的合并交集区间区间，如果后面的气球直径范围区间也在交集区间内，那么一支箭足以，否则说明后面气球直径和范围不在当前箭的贯穿范围内，我们需要更新下一之箭的贯穿范围</p><p><img src="/./../../images/%E6%80%9D%E8%B7%AF/LE452%EF%BC%882%EF%BC%89.png"></p><p>同时可以发现按左起始点排序，只要第一个气球直径的右终点大于等于第二个区间的气球直径左起始点，那么这两个气球必然有重合直径，将交集区间更新为这个新的最小直径重合区间。</p><h2 id="自己代码实现"><a href="#自己代码实现" class="headerlink" title="自己代码实现"></a>自己代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//按左边最左值，从小到大排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//思路比较简单</span></span><br><span class="line">        <span class="comment">//我们只要找出水平直径有交叉的即可</span></span><br><span class="line">        <span class="comment">//为了保证更好的合并，可以取点的最左下标进行排序，然后依次比较最右下标</span></span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>; </span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="type">int</span> tempLeft = points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> tempRight = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//只要第二区间的左值小于等于第一个交集区间右值</span></span><br><span class="line">           <span class="keyword">if</span>(points[i][<span class="number">0</span>] &lt;= tempRight)</span><br><span class="line">           &#123;</span><br><span class="line">                <span class="comment">//更新交集区间</span></span><br><span class="line">                tempLeft = <span class="built_in">max</span>(tempLeft, points[i][<span class="number">0</span>]);  <span class="comment">//更新交集左值</span></span><br><span class="line">                tempRight = <span class="built_in">min</span>(tempRight, points[i][<span class="number">1</span>]);  <span class="comment">//更新交集右值</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//不在前面弓箭的交集范围内</span></span><br><span class="line">                result++;</span><br><span class="line">                tempLeft = points[i][<span class="number">0</span>];</span><br><span class="line">                tempRight = points[i][<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="优化代码（上述代码简化版）"><a href="#优化代码（上述代码简化版）" class="headerlink" title="优化代码（上述代码简化版）"></a>优化代码（上述代码简化版）</h2><p>不需要考虑重合直径，因为已经排好序了，只要第一个气球的右终点大于等于第二个气球的左起始点，必然挨着。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//按左边最左值，从小到大排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;  <span class="comment">//points不为空，至少有一只箭</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; points.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//气球i和气球i-1不挨着</span></span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; points[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                points[i][<span class="number">1</span>] = <span class="built_in">min</span>(points[i<span class="number">-1</span>][<span class="number">1</span>], points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>神经网络架构</title>
      <link href="/2024/12/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"/>
      <url>/2024/12/01/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>量子鸢尾花分类</title>
      <link href="/2024/11/30/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E9%A1%B9%E7%9B%AE/%E9%87%8F%E5%AD%90%E9%B8%A2%E5%B0%BE%E8%8A%B1%E5%88%86%E7%B1%BB/"/>
      <url>/2024/11/30/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E9%A1%B9%E7%9B%AE/%E9%87%8F%E5%AD%90%E9%B8%A2%E5%B0%BE%E8%8A%B1%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><h2 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">3.999999999999999112e-01 7.500000000000000000e-01 1.999999999999999556e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.000000000000002665e-01 5.000000000000000000e-01 1.999999999999999556e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">2.000000000000001776e-01 6.000000000000000888e-01 1.500000000000000222e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">1.499999999999999112e-01 5.500000000000000444e-01 2.500000000000000000e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.500000000000000888e-01 8.000000000000000444e-01 1.999999999999999556e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">5.500000000000002665e-01 9.499999999999999556e-01 3.499999999999999778e-01 1.500000000000000222e-01 -1.000000000000000000e+00</span><br><span class="line">1.499999999999999112e-01 6.999999999999999556e-01 1.999999999999999556e-01 9.999999999999999167e-02 -1.000000000000000000e+00</span><br><span class="line">3.500000000000000888e-01 6.999999999999999556e-01 2.500000000000000000e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">5.000000000000026645e-02 4.499999999999999556e-01 1.999999999999999556e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.000000000000002665e-01 5.500000000000000444e-01 2.500000000000000000e-01 0.000000000000000000e+00 -1.000000000000000000e+00</span><br><span class="line">5.500000000000002665e-01 8.500000000000000888e-01 2.500000000000000000e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">2.500000000000000000e-01 6.999999999999999556e-01 3.000000000000000444e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">2.500000000000000000e-01 5.000000000000000000e-01 1.999999999999999556e-01 0.000000000000000000e+00 -1.000000000000000000e+00</span><br><span class="line">0.000000000000000000e+00 5.000000000000000000e-01 5.000000000000004441e-02 0.000000000000000000e+00 -1.000000000000000000e+00</span><br><span class="line">7.500000000000000000e-01 1.000000000000000000e+00 9.999999999999997780e-02 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">7.000000000000001776e-01 1.200000000000000178e+00 2.500000000000000000e-01 1.500000000000000222e-01 -1.000000000000000000e+00</span><br><span class="line">5.500000000000002665e-01 9.499999999999999556e-01 1.500000000000000222e-01 1.500000000000000222e-01 -1.000000000000000000e+00</span><br><span class="line">3.999999999999999112e-01 7.500000000000000000e-01 1.999999999999999556e-01 9.999999999999999167e-02 -1.000000000000000000e+00</span><br><span class="line">7.000000000000001776e-01 8.999999999999999112e-01 3.499999999999999778e-01 9.999999999999999167e-02 -1.000000000000000000e+00</span><br><span class="line">3.999999999999999112e-01 8.999999999999999112e-01 2.500000000000000000e-01 9.999999999999999167e-02 -1.000000000000000000e+00</span><br><span class="line">5.500000000000002665e-01 6.999999999999999556e-01 3.499999999999999778e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.999999999999999112e-01 8.500000000000000888e-01 2.500000000000000000e-01 1.500000000000000222e-01 -1.000000000000000000e+00</span><br><span class="line">1.499999999999999112e-01 8.000000000000000444e-01 0.000000000000000000e+00 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.999999999999999112e-01 6.499999999999999112e-01 3.499999999999999778e-01 2.000000000000000111e-01 -1.000000000000000000e+00</span><br><span class="line">2.500000000000000000e-01 6.999999999999999556e-01 4.499999999999999556e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.500000000000000888e-01 5.000000000000000000e-01 3.000000000000000444e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.500000000000000888e-01 6.999999999999999556e-01 3.000000000000000444e-01 1.500000000000000222e-01 -1.000000000000000000e+00</span><br><span class="line">4.500000000000001776e-01 7.500000000000000000e-01 2.500000000000000000e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">4.500000000000001776e-01 6.999999999999999556e-01 1.999999999999999556e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">2.000000000000001776e-01 6.000000000000000888e-01 3.000000000000000444e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">2.500000000000000000e-01 5.500000000000000444e-01 3.000000000000000444e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">5.500000000000002665e-01 6.999999999999999556e-01 2.500000000000000000e-01 1.500000000000000222e-01 -1.000000000000000000e+00</span><br><span class="line">4.500000000000001776e-01 1.049999999999999822e+00 2.500000000000000000e-01 0.000000000000000000e+00 -1.000000000000000000e+00</span><br><span class="line">6.000000000000000888e-01 1.100000000000000089e+00 1.999999999999999556e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.000000000000002665e-01 5.500000000000000444e-01 2.500000000000000000e-01 0.000000000000000000e+00 -1.000000000000000000e+00</span><br><span class="line">3.500000000000000888e-01 6.000000000000000888e-01 9.999999999999997780e-02 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">6.000000000000000888e-01 7.500000000000000000e-01 1.500000000000000222e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.000000000000002665e-01 5.500000000000000444e-01 2.500000000000000000e-01 0.000000000000000000e+00 -1.000000000000000000e+00</span><br><span class="line">5.000000000000026645e-02 5.000000000000000000e-01 1.500000000000000222e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.999999999999999112e-01 6.999999999999999556e-01 2.500000000000000000e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.500000000000000888e-01 7.500000000000000000e-01 1.500000000000000222e-01 9.999999999999999167e-02 -1.000000000000000000e+00</span><br><span class="line">1.000000000000000888e-01 1.499999999999999112e-01 1.500000000000000222e-01 9.999999999999999167e-02 -1.000000000000000000e+00</span><br><span class="line">5.000000000000026645e-02 6.000000000000000888e-01 1.500000000000000222e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.500000000000000888e-01 7.500000000000000000e-01 3.000000000000000444e-01 2.500000000000000000e-01 -1.000000000000000000e+00</span><br><span class="line">3.999999999999999112e-01 8.999999999999999112e-01 4.499999999999999556e-01 1.500000000000000222e-01 -1.000000000000000000e+00</span><br><span class="line">2.500000000000000000e-01 5.000000000000000000e-01 1.999999999999999556e-01 9.999999999999999167e-02 -1.000000000000000000e+00</span><br><span class="line">3.999999999999999112e-01 8.999999999999999112e-01 3.000000000000000444e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">1.499999999999999112e-01 6.000000000000000888e-01 1.999999999999999556e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">5.000000000000000000e-01 8.500000000000000888e-01 2.500000000000000000e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">3.500000000000000888e-01 6.499999999999999112e-01 1.999999999999999556e-01 5.000000000000000278e-02 -1.000000000000000000e+00</span><br><span class="line">1.350000000000000089e+00 6.000000000000000888e-01 1.850000000000000089e+00 6.499999999999999112e-01 1.000000000000000000e+00</span><br><span class="line">1.050000000000000266e+00 6.000000000000000888e-01 1.750000000000000000e+00 6.999999999999999556e-01 1.000000000000000000e+00</span><br><span class="line">1.300000000000000266e+00 5.500000000000000444e-01 1.950000000000000178e+00 6.999999999999999556e-01 1.000000000000000000e+00</span><br><span class="line">6.000000000000000888e-01 1.499999999999999112e-01 1.500000000000000000e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">1.100000000000000089e+00 3.999999999999999112e-01 1.799999999999999822e+00 6.999999999999999556e-01 1.000000000000000000e+00</span><br><span class="line">7.000000000000001776e-01 3.999999999999999112e-01 1.750000000000000000e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">1.000000000000000000e+00 6.499999999999999112e-01 1.850000000000000089e+00 7.500000000000000000e-01 1.000000000000000000e+00</span><br><span class="line">3.000000000000002665e-01 1.999999999999999556e-01 1.149999999999999911e+00 4.500000000000000111e-01 1.000000000000000000e+00</span><br><span class="line">1.149999999999999911e+00 4.499999999999999556e-01 1.799999999999999822e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">4.500000000000001776e-01 3.500000000000000888e-01 1.449999999999999956e+00 6.499999999999999112e-01 1.000000000000000000e+00</span><br><span class="line">3.500000000000000888e-01 0.000000000000000000e+00 1.250000000000000000e+00 4.500000000000000111e-01 1.000000000000000000e+00</span><br><span class="line">8.000000000000002665e-01 5.000000000000000000e-01 1.600000000000000089e+00 6.999999999999999556e-01 1.000000000000000000e+00</span><br><span class="line">8.500000000000000888e-01 1.000000000000000888e-01 1.500000000000000000e+00 4.500000000000000111e-01 1.000000000000000000e+00</span><br><span class="line">8.999999999999999112e-01 4.499999999999999556e-01 1.850000000000000089e+00 6.499999999999999112e-01 1.000000000000000000e+00</span><br><span class="line">6.499999999999999112e-01 4.499999999999999556e-01 1.300000000000000044e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">1.200000000000000178e+00 5.500000000000000444e-01 1.700000000000000178e+00 6.499999999999999112e-01 1.000000000000000000e+00</span><br><span class="line">6.499999999999999112e-01 5.000000000000000000e-01 1.750000000000000000e+00 6.999999999999999556e-01 1.000000000000000000e+00</span><br><span class="line">7.500000000000000000e-01 3.500000000000000888e-01 1.549999999999999822e+00 4.500000000000000111e-01 1.000000000000000000e+00</span><br><span class="line">9.500000000000001776e-01 1.000000000000000888e-01 1.750000000000000000e+00 6.999999999999999556e-01 1.000000000000000000e+00</span><br><span class="line">6.499999999999999112e-01 2.500000000000000000e-01 1.449999999999999956e+00 5.000000000000000000e-01 1.000000000000000000e+00</span><br><span class="line">8.000000000000002665e-01 6.000000000000000888e-01 1.899999999999999911e+00 8.499999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">8.999999999999999112e-01 3.999999999999999112e-01 1.500000000000000000e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">1.000000000000000000e+00 2.500000000000000000e-01 1.950000000000000178e+00 6.999999999999999556e-01 1.000000000000000000e+00</span><br><span class="line">8.999999999999999112e-01 3.999999999999999112e-01 1.850000000000000089e+00 5.499999999999999334e-01 1.000000000000000000e+00</span><br><span class="line">1.050000000000000266e+00 4.499999999999999556e-01 1.649999999999999911e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">1.149999999999999911e+00 5.000000000000000000e-01 1.700000000000000178e+00 6.499999999999999112e-01 1.000000000000000000e+00</span><br><span class="line">1.250000000000000000e+00 3.999999999999999112e-01 1.899999999999999911e+00 6.499999999999999112e-01 1.000000000000000000e+00</span><br><span class="line">1.200000000000000178e+00 5.000000000000000000e-01 2.000000000000000000e+00 7.999999999999999334e-01 1.000000000000000000e+00</span><br><span class="line">8.500000000000000888e-01 4.499999999999999556e-01 1.750000000000000000e+00 6.999999999999999556e-01 1.000000000000000000e+00</span><br><span class="line">7.000000000000001776e-01 3.000000000000000444e-01 1.250000000000000000e+00 4.500000000000000111e-01 1.000000000000000000e+00</span><br><span class="line">6.000000000000000888e-01 1.999999999999999556e-01 1.399999999999999911e+00 5.000000000000000000e-01 1.000000000000000000e+00</span><br><span class="line">6.000000000000000888e-01 1.999999999999999556e-01 1.350000000000000089e+00 4.500000000000000111e-01 1.000000000000000000e+00</span><br><span class="line">7.500000000000000000e-01 3.500000000000000888e-01 1.449999999999999956e+00 5.499999999999999334e-01 1.000000000000000000e+00</span><br><span class="line">8.500000000000000888e-01 3.500000000000000888e-01 2.049999999999999822e+00 7.500000000000000000e-01 1.000000000000000000e+00</span><br><span class="line">5.500000000000002665e-01 5.000000000000000000e-01 1.750000000000000000e+00 6.999999999999999556e-01 1.000000000000000000e+00</span><br><span class="line">8.500000000000000888e-01 6.999999999999999556e-01 1.750000000000000000e+00 7.500000000000000000e-01 1.000000000000000000e+00</span><br><span class="line">1.200000000000000178e+00 5.500000000000000444e-01 1.850000000000000089e+00 6.999999999999999556e-01 1.000000000000000000e+00</span><br><span class="line">1.000000000000000000e+00 1.499999999999999112e-01 1.700000000000000178e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">6.499999999999999112e-01 5.000000000000000000e-01 1.549999999999999822e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">6.000000000000000888e-01 2.500000000000000000e-01 1.500000000000000000e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">6.000000000000000888e-01 3.000000000000000444e-01 1.700000000000000178e+00 5.499999999999999334e-01 1.000000000000000000e+00</span><br><span class="line">8.999999999999999112e-01 5.000000000000000000e-01 1.799999999999999822e+00 6.499999999999999112e-01 1.000000000000000000e+00</span><br><span class="line">7.500000000000000000e-01 3.000000000000000444e-01 1.500000000000000000e+00 5.499999999999999334e-01 1.000000000000000000e+00</span><br><span class="line">3.500000000000000888e-01 1.499999999999999112e-01 1.149999999999999911e+00 4.500000000000000111e-01 1.000000000000000000e+00</span><br><span class="line">6.499999999999999112e-01 3.500000000000000888e-01 1.600000000000000089e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">7.000000000000001776e-01 5.000000000000000000e-01 1.600000000000000089e+00 5.499999999999999334e-01 1.000000000000000000e+00</span><br><span class="line">7.000000000000001776e-01 4.499999999999999556e-01 1.600000000000000089e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">9.500000000000001776e-01 4.499999999999999556e-01 1.649999999999999911e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line">3.999999999999999112e-01 2.500000000000000000e-01 1.000000000000000000e+00 5.000000000000000000e-01 1.000000000000000000e+00</span><br><span class="line">7.000000000000001776e-01 3.999999999999999112e-01 1.549999999999999822e+00 5.999999999999999778e-01 1.000000000000000000e+00</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="逐个代码剖析"><a href="#逐个代码剖析" class="headerlink" title="逐个代码剖析"></a>逐个代码剖析</h3><h4 id="1-项目所需头文件"><a href="#1-项目所需头文件" class="headerlink" title="1. 项目所需头文件"></a>1. 项目所需头文件</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pennyLane 是一个开源的量子计算库，旨在使量子计算与机器学习、优化和其他                             经典计算领域结合起来。</span></span><br><span class="line"><span class="keyword">import</span> pennylane <span class="keyword">as</span> qml  </span><br><span class="line"></span><br><span class="line"><span class="comment"># NumPy 是 Python 中用于数值计算的核心库，提供了高效的多维数组操作、矩阵运算、线性代数功能、傅里叶变换、随机数生成等。</span></span><br><span class="line"><span class="keyword">from</span> pennylane <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># NesterovMomentumOptimizer 是 PennyLane 提供的一种优化器，通常用于变分量子算法（VQA）中。它实现了 Nesterov 动量优化方法，该方法是一种基于梯度下降的加速优化算法，用于寻找损失函数的最小值。</span></span><br><span class="line"><span class="keyword">from</span> pennylane.optimize <span class="keyword">import</span> NesterovMomentumOptimizer</span><br><span class="line"></span><br><span class="line"><span class="comment"># arcsin 是 NumPy 库中的一个数学函数，表示反正弦（逆正弦）函数。给定一个值，它返回该值的反正弦（即角度）。其定义为 arcsin(x)，返回值为角度（弧度制）。</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> arcsin</span><br></pre></td></tr></table></figure><h4 id="2-所使用的量子设备"><a href="#2-所使用的量子设备" class="headerlink" title="2.所使用的量子设备"></a>2.所使用的量子设备</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dev = qml.device(<span class="string">&#x27;lightning.qubit&#x27;</span>, wires=(<span class="number">0</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>**<code>qml.device</code>**：这是 PennyLane 中用于创建量子设备的函数。通过它，可以指定你要使用的量子硬件或模拟器。</p><p>**<code>&#39;lightning.qubit&#39;</code>**：这里选择了 <strong>lightning.qubit</strong> 作为设备类型。<code>lightning.qubit</code> 是 PennyLane 提供的一个高效的模拟器，用于在 CPU 上模拟量子计算。它是基于 <strong>Lightning</strong> 框架开发的，速度较快，适合进行小规模的量子计算仿真。</p><ul><li>如果你想要使用实际的量子硬件（如 <strong>IBM Q</strong>、<strong>Rigetti</strong> 等），可以通过提供对应的设备名（例如 <code>&#39;ibmq&#39;</code>）来选择硬件设备。</li></ul><p>**<code>wires=(0, 1)</code>**：这表示量子设备有两个量子比特（qubits），分别位于 <strong>wire 0</strong> 和 <strong>wire 1</strong>。在 PennyLane 中，<code>wires</code> 参数指定了量子比特的数量和它们的索引。这里创建的是一个有两个量子比特的设备。</p><h4 id="3-计算输入数组的角度值"><a href="#3-计算输入数组的角度值" class="headerlink" title="3.计算输入数组的角度值"></a>3.计算输入数组的角度值</h4><p>为后面量子线路旋转角度做准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_angles</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="comment"># 这三行代码计算了三个角度值，有反正弦计算得到</span></span><br><span class="line">    <span class="comment"># 计算x[0]和x[1]的平方和的反正弦值  1e-12避免除0错误</span></span><br><span class="line">    beta0 = <span class="number">2</span> * np.arcsin(np.sqrt(x[<span class="number">1</span>] ** <span class="number">2</span>) / np.sqrt(x[<span class="number">0</span>] ** <span class="number">2</span> + x[<span class="number">1</span>] ** <span class="number">2</span> + <span class="number">1e-12</span>))</span><br><span class="line">    <span class="comment"># 计算x[2]和x[3]的平方和的反正弦值  1e-12避免除0错误</span></span><br><span class="line">    beta1 = <span class="number">2</span> * np.arcsin(np.sqrt(x[<span class="number">3</span>] ** <span class="number">2</span>) / np.sqrt(x[<span class="number">2</span>] ** <span class="number">2</span> + x[<span class="number">3</span>] ** <span class="number">2</span> + <span class="number">1e-12</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># beta2 是通过计算从 x[2] 到 x[n]（即 x[2:]）的欧几里得范数与 x 数组的总范数的比值，之后取反     # 正弦并乘以 2</span></span><br><span class="line">    beta2 = <span class="number">2</span> * np.arcsin(np.linalg.norm(x[<span class="number">2</span>:]) / np.linalg.norm(x))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 最终返回一个数组，包含了五个计算出的角度值。这里的 beta1 和 beta0 的值被分别取了正负一半。</span></span><br><span class="line">    <span class="keyword">return</span> np.array([beta2, -beta1 / <span class="number">2</span>, beta1 / <span class="number">2</span>, -beta0 / <span class="number">2</span>, beta0 / <span class="number">2</span>])</span><br></pre></td></tr></table></figure><h4 id="4-量子线路准备"><a href="#4-量子线路准备" class="headerlink" title="4.量子线路准备"></a>4.量子线路准备</h4><p><img src="/./../../images/%E9%A1%B9%E7%9B%AE%E5%9B%BE/%E9%87%8F%E5%AD%90%E7%B4%AB%E8%96%87%E8%8A%B1/04.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">state_preparation</span>(<span class="params">a</span>):</span><br><span class="line">    qml.RY(a[<span class="number">0</span>], wires=<span class="number">0</span>)  </span><br><span class="line"></span><br><span class="line">    qml.CNOT(wires=[<span class="number">0</span>, <span class="number">1</span>])  </span><br><span class="line">    qml.RY(a[<span class="number">1</span>], wires=<span class="number">1</span>)  </span><br><span class="line">    qml.CNOT(wires=[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    qml.RY(a[<span class="number">2</span>], wires=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    qml.PauliX(wires=<span class="number">0</span>)</span><br><span class="line">    qml.CNOT(wires=[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    qml.RY(a[<span class="number">3</span>], wires=<span class="number">1</span>)</span><br><span class="line">    qml.CNOT(wires=[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    qml.RY(a[<span class="number">4</span>], wires=<span class="number">1</span>)</span><br><span class="line">    qml.PauliX(wires=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>（1）**<code>RY(a[0], wires=0)</code>**：这行代码给第 0 号量子比特应用了一个旋转门 <code>RY</code>，其角度为 <code>a[0]</code>。<code>RY(θ)</code> 是绕 Y 轴旋转的门，作用是改变量子比特的相位。</p><p>（2）**<code>qml.CNOT(wires=[0, 1])</code>**：应用一个 <strong>CNOT</strong> 门，控制比特为量子比特 0，目标比特为量子比特 1。该操作将 <code>q[1]</code> 与 <code>q[0]</code> 纠缠。</p><p>（3）**<code>qml.RY(a[1], wires=1)</code>**：这行代码给第 1 号量子比特应用了一个 <code>RY</code> 门，旋转角度为 <code>a[1]</code>。</p><p>（4）**<code>qml.PauliX(wires=0)</code>**：这行代码给第 0 号量子比特应用了一个 Pauli X 门，Pauli X 门相当于经典的 NOT 门，会将量子比特从 |0&gt; 状态翻转为 |1&gt; 状态，反之亦然。</p><p>（5）<strong>CNOT 和 RY 的重复应用</strong>：</p><p>​        该部分代码与前面类似，通过 CNOT 和 RY 门进一步调整量子比特之间的关系，可能用于将量子信息纠缠。</p><p>（6）<strong>重复的 <code>CNOT</code> 和 <code>RY</code> 操作</strong>：</p><p>​        第 1 号量子比特的旋转角度分别为 <code>a[2]</code> 和 <code>a[4]</code>，并且应用了 CNOT 门，这可能用于在两个量子比特之间建立进一步的量子纠缠。</p><h4 id="5-测试设计的量子线路是否有效"><a href="#5-测试设计的量子线路是否有效" class="headerlink" title="5.测试设计的量子线路是否有效"></a>5.测试设计的量子线路是否有效</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个输入值</span></span><br><span class="line">x = np.array([<span class="number">0.53896774</span>, <span class="number">0.79503606</span>, <span class="number">0.27826503</span>, <span class="number">0.0</span>], requires_grad=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 对输入值转换成角度</span></span><br><span class="line">ang = get_angles(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处为量子结点，后续的量子函数将在已经定义好的dev上运行</span></span><br><span class="line"><span class="meta">@qml.qnode(<span class="params">dev</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用计算出的角度来对量子门的旋转角度进行处理</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">angles</span>):</span><br><span class="line">    state_preparation(angles)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qml.state()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state = test(ang)</span><br><span class="line"></span><br><span class="line"><span class="comment"># np.round 是 NumPy 库中的一个函数，用于将数字或数组的元素四舍五入到指定的小数位数。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x               : &quot;</span>, np.<span class="built_in">round</span>(x, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;angles          : &quot;</span>, np.<span class="built_in">round</span>(ang, <span class="number">6</span>))</span><br><span class="line"><span class="comment"># 这行代码的作用是输出量子状态的幅度向量的实部</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;amplitude vector: &quot;</span>, np.<span class="built_in">round</span>(np.real(state), <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;该方法计算了正确的角度以及准备所需要的态&quot;</span>)</span><br></pre></td></tr></table></figure><p>输出结果如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x         :  [0.538968 0.795036 0.278265 0.      ]</span><br><span class="line">angles          :  [ 0.563975 -0.        0.       -0.975046  0.975046]</span><br><span class="line">amplitude vector:  [ 0.538968  0.795036  0.278265 -0.      ]</span><br><span class="line">该方法计算了正确的角度以及准备所需要的态</span><br></pre></td></tr></table></figure><h4 id="6-一些测试函数"><a href="#6-一些测试函数" class="headerlink" title="6.一些测试函数"></a>6.一些测试函数</h4><p>（1）计算 均方误差 (MSE)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square_loss</span>(<span class="params">labels, predictions</span>):</span><br><span class="line">    <span class="comment"># We use a call to qml.math.stack to allow subtracting the arrays directly</span></span><br><span class="line">    <span class="keyword">return</span> np.mean((labels - qml.math.stack(predictions)) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>输入参数：</strong></p><ul><li>**<code>labels</code>**：表示真实标签或实际值。通常是一个 NumPy 数组或张量，代表真实的目标值。</li><li>**<code>predictions</code>**：表示模型的预测值，通常是来自模型或量子电路的预测值。这可能是一个列表或数组。</li></ul><p>**<code>qml.math.stack(predictions)</code>**：</p><ul><li><code>qml.math.stack</code> 用于确保 <code>predictions</code> 数组的格式是可以直接与 <code>labels</code> 相减的。这通常是为了确保输入数据的统一性，尤其是在量子计算框架中，预测结果可能以不同的格式返回（例如列表或张量）。</li><li>如果 <code>predictions</code> 已经是一个标准的 NumPy 数组，这一步可能不必要，但在使用 PennyLane 等量子计算库时，这样做可以确保兼容性，避免类型或结构的冲突。</li></ul><p>**(labels - qml.math.stack(predictions))&#96;**：</p><ul><li>这是真实标签和预测值之间的误差项（即差值）。它是逐元素计算的（每个 <code>labels</code> 和 <code>predictions</code> 数组中对应位置的元素相减）。</li></ul><p>**<code>(labels - qml.math.stack(predictions)) \** 2</code>**：</p><ul><li>对误差进行逐元素平方，这是均方误差（MSE）计算中的关键步骤。平方误差可以确保无论误差是正还是负，都会对损失值产生积极的贡献，并且较大的误差会受到更大的惩罚。</li></ul><p> **np.mean(…)&#96;**：</p><ul><li><code>np.mean</code> 计算所有平方误差的平均值，这就是 **均方误差 (MSE)**，它提供一个代表预测值和实际值之间总体误差的单一数值。</li></ul><p>（2）准确度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">labels, predictions</span>):</span><br><span class="line">    acc = <span class="built_in">sum</span>(<span class="built_in">abs</span>(l - p) &lt; <span class="number">1e-5</span> <span class="keyword">for</span> l, p <span class="keyword">in</span> <span class="built_in">zip</span>(labels, predictions))</span><br><span class="line">    acc = acc / <span class="built_in">len</span>(labels)</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>[1]<strong><code>labels</code> 和 <code>predictions</code>：</strong></p><ul><li>**<code>labels</code>**：表示真实的标签或目标值，通常是一个 NumPy 数组或列表。</li><li>**<code>predictions</code>**：表示模型的预测值，通常是来自模型或量子电路的预测结果，也可以是一个数组或列表。</li></ul><p>[2]<strong><code>zip(labels, predictions)</code>：</strong></p><ul><li><code>zip</code> 函数将 <code>labels</code> 和 <code>predictions</code> 中的对应元素打包成一个个元组，例如 <code>(l1, p1), (l2, p2), ...</code>。这样可以便于后续逐对比对每个标签和预测值。</li></ul><p>[3]<strong><code>abs(l - p) &lt; 1e-5</code>：</strong></p><ul><li>对每一对 <code>(l, p)</code>（即真实标签和预测值）进行比较，计算它们的差值并判断差值是否小于 1×10−51 \times 10^{-5}1×10−5。</li><li>这里使用了 <code>abs</code> 函数来计算它们的绝对差值，<code>1e-5</code> 是一个小的容差，用于处理可能的数值精度误差。</li><li>如果绝对差值小于 <code>1e-5</code>，就认为这次预测是正确的，否则认为预测错误。</li></ul><p>[4]<strong><code>sum(abs(l - p) &lt; 1e-5 for l, p in zip(labels, predictions))</code>：</strong></p><ul><li><code>sum()</code> 函数计算 <code>True</code> 的数量。由于 <code>True</code> 被当作 <code>1</code> 处理，<code>False</code> 被当作 <code>0</code>，所以这个表达式最终会返回预测正确的个数。</li></ul><p>[5]<strong><code>acc = acc / len(labels)</code>：</strong></p><ul><li>将预测正确的个数除以标签的总数，得到准确率。这个值是一个介于 0 和 1 之间的浮动值，表示模型预测的准确性。</li></ul><p>[6]<strong><code>return acc</code>：</strong></p><ul><li>返回最终的准确率值。</li></ul><p>（3）成本函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cost</span>(<span class="params">weights, bias, X, Y</span>):</span><br><span class="line">    <span class="comment"># Transpose the batch of input data in order to make the indexing</span></span><br><span class="line">    <span class="comment"># in state_preparation work</span></span><br><span class="line">    predictions = variational_classifier(weights, bias, X.T) <span class="comment"># 计算出预测值</span></span><br><span class="line">    <span class="keyword">return</span> square_loss(Y, predictions) <span class="comment"># 返回实际值和预测值的均方误差</span></span><br></pre></td></tr></table></figure><h4 id="7-重构量子层"><a href="#7-重构量子层" class="headerlink" title="7.重构量子层"></a>7.重构量子层</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">layer</span>(<span class="params">layer_weights</span>):</span><br><span class="line">    <span class="keyword">for</span> wire <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        qml.Rot(*layer_weights[wire], wires=wire)</span><br><span class="line">    qml.CNOT(wires=[<span class="number">0</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ol><li>**<code>layer_weights</code>**：<ul><li><code>layer_weights</code> 是一个包含量子比特旋转角度的输入列表或数组。这个参数应该是一个长度为 2 的列表或数组，<strong>每个元素包含三个旋转角度（<code>θ</code>, <code>φ</code>, <code>λ</code>）</strong>，这三个角度将被传递给 <code>qml.Rot</code> 门来定义旋转。</li></ul></li><li>**<code>for wire in range(2)</code>**：<ul><li>这个 <code>for</code> 循环遍历量子比特 <code>0</code> 和 <code>1</code>（即量子线路中的两个量子比特）。在这个循环中，我们对每个量子比特应用旋转门。</li></ul></li><li>**<code>qml.Rot(\*layer_weights[wire], wires=wire)</code>**：<ul><li><code>qml.Rot</code> 是一个量子门，表示对指定量子比特的旋转。<code>*layer_weights[wire]</code> 将从 <code>layer_weights</code> 中取出一个三元组，分别对应旋转门的三个参数 <code>θ</code>, <code>φ</code>, 和 <code>λ</code>，这些参数决定了旋转的角度。</li><li><code>wires=wire</code> 指定了旋转门作用的量子比特，<code>wire</code> 在这里取值 0 或 1。</li></ul></li><li>**<code>qml.CNOT(wires=[0, 1])</code>**：<ul><li>在两个旋转门之后，<code>qml.CNOT</code> 门（受控非门）被应用在量子比特 <code>0</code> 和 <code>1</code> 上，其中量子比特 0 是控制比特，量子比特 1 是目标比特。</li><li>如果控制比特（量子比特 0）处于状态 <code>|1⟩</code>，则会翻转目标比特（量子比特 1）。这是量子计算中的一个常见操作，广泛用于量子纠缠生成和量子线路中的条件操作。</li></ul></li></ol><h4 id="8-全连接层和变分量子分类器"><a href="#8-全连接层和变分量子分类器" class="headerlink" title="8.全连接层和变分量子分类器"></a>8.全连接层和变分量子分类器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@qml.qnode(<span class="params">dev</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">circuit</span>(<span class="params">weights, x</span>):</span><br><span class="line">    state_preparation(x) <span class="comment"># 得到量子比特的初始态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> layer_weights <span class="keyword">in</span> weights:</span><br><span class="line">        layer(layer_weights)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qml.expval(qml.PauliZ(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">variational_classifier</span>(<span class="params">weights, bias, x</span>):</span><br><span class="line">    <span class="keyword">return</span> circuit(weights, x) + bias</span><br></pre></td></tr></table></figure><h3 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h3><ol><li><strong>装饰器 <code>@qml.qnode(dev)</code></strong></li></ol><ul><li><code>@qml.qnode(dev)</code> 是 Pennylane 的一个装饰器，表示该函数是一个量子节点（QNode）。在 Pennylane 中，QNode 是量子电路的封装函数，可以接受输入数据（如 <code>x</code> 和 <code>weights</code>），并返回量子电路的输出结果。</li><li><code>dev</code> 是你量子设备的实例，通常是一个模拟设备或者量子硬件的接口，定义了该电路的执行环境（例如是一个模拟器或者一个量子硬件设备）。</li></ul><ol start="2"><li><strong><code>circuit</code> 函数</strong></li></ol><p><code>circuit</code> 函数的输入参数是：</p><ul><li><strong><code>weights</code></strong>: 该参数是一个列表，其中包含了每一层的旋转门角度，通常是量子神经网络中的可调参数（例如，量子电路中的旋转角度）。</li><li><strong><code>x</code></strong>: 输入数据，通常是一个特征向量。<code>x</code> 将被用于量子电路中的状态准备过程。</li></ul><ol start="3"><li><strong><code>state_preparation(x)</code></strong></li></ol><ul><li>这个函数调用是用来初始化量子比特的状态。它将根据输入 <code>x</code> 中的数据来设置量子比特的初始状态。我们之前看到过 <code>state_preparation</code> 函数，它应用了旋转门和 CNOT 门来生成<strong>量子比特的初始状态</strong>。</li></ul><ol start="4"><li><strong><code>for layer_weights in weights:</code></strong></li></ol><ul><li>这个循环遍历了所有的层的旋转角度。每一层的旋转角度（<code>layer_weights</code>）都会传递给 <code>layer</code> 函数，<code>layer</code> 函数会对量子比特应用旋转门和 CNOT 门，构建出量子电路的各层。</li></ul><ol start="5"><li><strong><code>qml.expval(qml.PauliZ(0))</code></strong></li></ol><ul><li><p>这是量子电路的输出部分。在量子计算中，<code>qml.expval</code> 用于计算量子比特的期望值。<code>qml.PauliZ(0)</code> 表示对量子比特 0 应用 Pauli-Z 算符。</p></li><li><p>Pauli-Z 算符</p><p> 是量子计算中一种常见的单量子比特算符，它作用在量子比特上时，将其状态 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|0⟩</span><br></pre></td></tr></table></figure><p> 保持不变，而将 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|1⟩</span><br></pre></td></tr></table></figure><p> 状态翻转。其矩阵表示为：<br>$$<br>Z &#x3D; \begin{pmatrix} 1 &amp; 0 \ 0 &amp; -1 \end{pmatrix}<br>$$</p><ul><li><code>qml.expval(qml.PauliZ(0))</code> 计算的是量子比特 0 的 Pauli-Z 算符的期望值。其结果为 +1 或 -1，表示量子比特 0 的最终状态是 <code>|0⟩</code> 还是 <code>|1⟩</code>。</li></ul></li></ul><h4 id="9-数据"><a href="#9-数据" class="headerlink" title="9.数据"></a>9.数据</h4><p>我们加载 Iris 数据集。为了将<strong>输入编码为量子态的振幅</strong>，需要进行一些预处理。我们将通过两个所谓的“潜在维度”来增加数据点，<strong>使填充数据点的大小与量子设备中的状态向量的大小相匹配</strong>。然后我们需要对<strong>数据点进行归一化</strong>，最后，我们<strong>使用<code>get_angles</code>上面定义的函数将输入 x 转换为旋转角度</strong>。</p><p>数据预处理应始终考虑到问题；例如，如果我们不添加任何潜在维度，则规范化会抹去有关向量长度的任何信息，并且该特征分隔的类别将无法区分。</p><h5 id="（1）数据扩维度来匹配相应的态"><a href="#（1）数据扩维度来匹配相应的态" class="headerlink" title="（1）数据扩维度来匹配相应的态"></a>（1）数据扩维度来匹配相应的态</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">data = np.loadtxt(<span class="string">&quot;iris_classes1and2_scaled.txt&quot;</span>)</span><br><span class="line"><span class="comment"># 取前两列数据</span></span><br><span class="line">X = data[:, <span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;First X sample (original)  : <span class="subst">&#123;X[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pad the vectors to size 2^2=4 with constant values</span></span><br><span class="line">padding = np.ones((<span class="built_in">len</span>(X), <span class="number">2</span>)) * <span class="number">0.1</span></span><br><span class="line">X_pad = np.c_[X, padding]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;First X sample (padded)    : <span class="subst">&#123;X_pad[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a>解释：</h3><ol><li><strong><code>padding = np.ones((len(X), 2)) \* 0.1</code></strong></li></ol><ul><li>这行代码创建了一个形状为 <code>(len(X), 2)</code> 的数组，其中 <code>len(X)</code> 是输入数据 <code>X</code> 中样本的数量，2 是目标维度差异，表示每个样本需要填充的维度大小。</li><li><code>np.ones((len(X), 2))</code> 生成一个所有元素为 1 的二维数组。</li><li>然后，通过 <code>* 0.1</code> 将数组中的所有值乘以 0.1，从而生成一个填充值为 0.1 的数组。这是填充操作，用来扩展每个输入样本的维度。</li></ul><ol start="2"><li><strong><code>X_pad = np.c_[X, padding]</code></strong></li></ol><ul><li><code>np.c_[X, padding]</code> 使用 <code>np.c_</code>（<strong>一个用于按列合并数组的快捷方式</strong>）将原始数据 <code>X</code> 和填充后的数组 <code>padding</code> 进行按列拼接。</li><li><code>X</code> 是输入数据矩阵，它的每一行表示一个样本，列表示特征。</li><li><strong>通过拼接 <code>padding</code>，每个样本的特征数（维度）从原来的大小增加到 4（原大小加上了填充的 2 个维度）。<code>X_pad</code> 是填充后的数据。</strong></li></ul><ol start="3"><li><strong><code>print(f&quot;First X sample (padded) : &#123;X_pad[0]&#125;&quot;)</code></strong></li></ol><ul><li><strong>这行代码打印填充后的 <code>X</code> 的第一个样本（即 <code>X_pad[0]</code>）</strong>。打印时，<code>f</code> 字符串格式化用于显示填充后的样本</li></ul><h5 id="（2）归一化处理"><a href="#（2）归一化处理" class="headerlink" title="（2）归一化处理"></a>（2）归一化处理</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># normalize each input</span></span><br><span class="line">normalization = np.sqrt(np.<span class="built_in">sum</span>(X_pad**<span class="number">2</span>, -<span class="number">1</span>))</span><br><span class="line">X_norm = (X_pad.T / normalization).T</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;First X sample (normalized): <span class="subst">&#123;X_norm[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><ol><li><em><strong><code>normalization = np.sqrt(np.sum(X_pad\**2, -1))</code></strong></em></li></ol><ul><li><p><strong>这行代码的作用是计算每个样本的欧几里得范数（L2 范数），用于归一化</strong>。</p></li><li><p><code>X_pad**2</code> 对 <code>X_pad</code> 数组中的每个元素进行平方。</p></li><li><p><code>np.sum(X_pad**2, -1)</code> 沿着每个样本的最后一个维度（即特征维度）求和。对于每个样本，它会计算特征平方的总和：<br>$$<br>\text{sum of squares} &#x3D; \sum_{i&#x3D;1}^n<br>$$<br>xi 是样本的各个特征。</p></li><li><p><code>np.sqrt()</code> 对每个样本的平方和结果取平方根，得到每个样本的欧几里得范数（即每个样本的模长）：</p><p>$$<br>\text{norm} &#x3D; \sqrt{\sum_{i&#x3D;1}^n x_i^2}<br>$$</p></li></ul><ol start="2"><li><em><strong><code>X_norm = (X_pad.T / normalization).T</code></strong></em></li></ol><ul><li><p><code>X_pad.T</code> 对 <code>X_pad</code> 进行转置，使得样本变成列，特征变成行。</p></li><li><p>然后，将每个样本（即每一列）除以对应的欧几里得范数 <code>normalization</code>，实现归一化。归一化的公式是：<br>$$<br>\hat{x}_i &#x3D; \frac{x_i}{|x|}<br>$$</p><p>$$<br>其中 𝑥^𝑖是归一化后的样本，𝑥𝑖 是原始样本，∥𝑥∥ 是该样本的欧几里得范数。<br>$$</p></li><li><p><code>X_pad.T / normalization</code> 这样操作时，每个特征都被对应的欧几里得范数归一化。</p></li><li><p><code>T</code> 将结果再转置回来，恢复成原来的样本和特征的形状。</p></li></ul><ol start="3"><li><em><strong><code>print(f&quot;First X sample (normalized): &#123;X_norm[0]&#125;&quot;)</code></strong></em></li></ol><ul><li>这行代码打印归一化后的 <code>X_norm</code> 的第一个样本（即 <code>X_norm[0]</code>）。</li><li>输出的样本已经经过了归一化处理，每个样本的特征值将处于一个单位范数内。</li></ul><h4 id="10-数据处理后可视化处理"><a href="#10-数据处理后可视化处理" class="headerlink" title="10.数据处理后可视化处理"></a>10.数据处理后可视化处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>][Y == <span class="number">1</span>], X[:, <span class="number">1</span>][Y == <span class="number">1</span>], c=<span class="string">&quot;b&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>][Y == -<span class="number">1</span>], X[:, <span class="number">1</span>][Y == -<span class="number">1</span>], c=<span class="string">&quot;r&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Original data&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/./../../images/%E9%A1%B9%E7%9B%AE%E5%9B%BE/%E9%87%8F%E5%AD%90%E7%B4%AB%E8%96%87%E8%8A%B1/01.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">dim1 = <span class="number">0</span></span><br><span class="line">dim2 = <span class="number">1</span></span><br><span class="line">plt.scatter(X_norm[:, dim1][Y == <span class="number">1</span>], X_norm[:, dim2][Y == <span class="number">1</span>], c=<span class="string">&quot;b&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.scatter(X_norm[:, dim1][Y == -<span class="number">1</span>], X_norm[:, dim2][Y == -<span class="number">1</span>], c=<span class="string">&quot;r&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.title(<span class="string">f&quot;Padded and normalised data (dims <span class="subst">&#123;dim1&#125;</span> and <span class="subst">&#123;dim2&#125;</span>)&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/./../../images/%E9%A1%B9%E7%9B%AE%E5%9B%BE/%E9%87%8F%E5%AD%90%E7%B4%AB%E8%96%87%E8%8A%B1/02.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">dim1 = <span class="number">0</span></span><br><span class="line">dim2 = <span class="number">3</span></span><br><span class="line">plt.scatter(features[:, dim1][Y == <span class="number">1</span>], features[:, dim2][Y == <span class="number">1</span>], c=<span class="string">&quot;b&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.scatter(features[:, dim1][Y == -<span class="number">1</span>], features[:, dim2][Y == -<span class="number">1</span>], c=<span class="string">&quot;r&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.title(<span class="string">f&quot;Feature vectors (dims <span class="subst">&#123;dim1&#125;</span> and <span class="subst">&#123;dim2&#125;</span>)&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/./../../images/%E9%A1%B9%E7%9B%AE%E5%9B%BE/%E9%87%8F%E5%AD%90%E7%B4%AB%E8%96%87%E8%8A%B1/03.png"></p><h4 id="11-泛化"><a href="#11-泛化" class="headerlink" title="11.泛化"></a>11.泛化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line">num_data = <span class="built_in">len</span>(Y)</span><br><span class="line">num_train = <span class="built_in">int</span>(<span class="number">0.75</span> * num_data)</span><br><span class="line">index = np.random.permutation(<span class="built_in">range</span>(num_data))</span><br><span class="line">feats_train = features[index[:num_train]]</span><br><span class="line">Y_train = Y[index[:num_train]]</span><br><span class="line">feats_val = features[index[num_train:]]</span><br><span class="line">Y_val = Y[index[num_train:]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># We need these later for plotting</span></span><br><span class="line">X_train = X[index[:num_train]]</span><br><span class="line">X_val = X[index[num_train:]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="12-优化"><a href="#12-优化" class="headerlink" title="12.优化"></a>12.优化</h4><p>初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num_qubits = <span class="number">2</span></span><br><span class="line">num_layers = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">weights_init = <span class="number">0.01</span> * np.random.randn(num_layers, num_qubits, <span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">bias_init = np.array(<span class="number">0.0</span>, requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>导入优化器来最小化成本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">opt = NesterovMomentumOptimizer(<span class="number">0.01</span>)</span><br><span class="line">batch_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># train the variational classifier</span></span><br><span class="line">weights = weights_init</span><br><span class="line">bias = bias_init</span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">60</span>):</span><br><span class="line">    <span class="comment"># Update the weights by one optimizer step</span></span><br><span class="line">    batch_index = np.random.randint(<span class="number">0</span>, num_train, (batch_size,))</span><br><span class="line">    feats_train_batch = feats_train[batch_index]</span><br><span class="line">    Y_train_batch = Y_train[batch_index]</span><br><span class="line">    weights, bias, _, _ = opt.step(cost, weights, bias, feats_train_batch, Y_train_batch)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute predictions on train and validation set</span></span><br><span class="line">    predictions_train = np.sign(variational_classifier(weights, bias, feats_train.T))</span><br><span class="line">    predictions_val = np.sign(variational_classifier(weights, bias, feats_val.T))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Compute accuracy on train and validation set</span></span><br><span class="line">    acc_train = accuracy(Y_train, predictions_train)</span><br><span class="line">    acc_val = accuracy(Y_val, predictions_val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        _cost = cost(weights, bias, features, Y)</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">f&quot;Iter: <span class="subst">&#123;it + <span class="number">1</span>:5d&#125;</span> | Cost: <span class="subst">&#123;_cost:<span class="number">0.7</span>f&#125;</span> | &quot;</span></span><br><span class="line">            <span class="string">f&quot;Acc train: <span class="subst">&#123;acc_train:<span class="number">0.7</span>f&#125;</span> | Acc validation: <span class="subst">&#123;acc_val:<span class="number">0.7</span>f&#125;</span>&quot;</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure><h4 id="13-绘制-Iris-数据集前两个维的变分分类器的连续输出"><a href="#13-绘制-Iris-数据集前两个维的变分分类器的连续输出" class="headerlink" title="13.绘制 Iris 数据集前两个维的变分分类器的连续输出"></a>13.绘制 Iris 数据集前两个维的变分分类器的连续输出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">cm = plt.cm.RdBu</span><br><span class="line"></span><br><span class="line"><span class="comment"># make data for decision regions</span></span><br><span class="line">xx, yy = np.meshgrid(np.linspace(<span class="number">0.0</span>, <span class="number">1.5</span>, <span class="number">30</span>), np.linspace(<span class="number">0.0</span>, <span class="number">1.5</span>, <span class="number">30</span>))</span><br><span class="line">X_grid = [np.array([x, y]) <span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(xx.flatten(), yy.flatten())]</span><br><span class="line"></span><br><span class="line"><span class="comment"># preprocess grid points like data inputs above</span></span><br><span class="line">padding = <span class="number">0.1</span> * np.ones((<span class="built_in">len</span>(X_grid), <span class="number">2</span>))</span><br><span class="line">X_grid = np.c_[X_grid, padding]  <span class="comment"># pad each input</span></span><br><span class="line">normalization = np.sqrt(np.<span class="built_in">sum</span>(X_grid**<span class="number">2</span>, -<span class="number">1</span>))</span><br><span class="line">X_grid = (X_grid.T / normalization).T  <span class="comment"># normalize each input</span></span><br><span class="line">features_grid = np.array([get_angles(x) <span class="keyword">for</span> x <span class="keyword">in</span> X_grid])  <span class="comment"># angles are new features</span></span><br><span class="line">predictions_grid = variational_classifier(weights, bias, features_grid.T)</span><br><span class="line">Z = np.reshape(predictions_grid, xx.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot decision regions</span></span><br><span class="line">levels = np.arange(-<span class="number">1</span>, <span class="number">1.1</span>, <span class="number">0.1</span>)</span><br><span class="line">cnt = plt.contourf(xx, yy, Z, levels=levels, cmap=cm, alpha=<span class="number">0.8</span>, extend=<span class="string">&quot;both&quot;</span>)</span><br><span class="line">plt.contour(xx, yy, Z, levels=[<span class="number">0.0</span>], colors=(<span class="string">&quot;black&quot;</span>,), linestyles=(<span class="string">&quot;--&quot;</span>,), linewidths=(<span class="number">0.8</span>,))</span><br><span class="line">plt.colorbar(cnt, ticks=[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot data</span></span><br><span class="line"><span class="keyword">for</span> color, label <span class="keyword">in</span> <span class="built_in">zip</span>([<span class="string">&quot;b&quot;</span>, <span class="string">&quot;r&quot;</span>], [<span class="number">1</span>, -<span class="number">1</span>]):</span><br><span class="line">    plot_x = X_train[:, <span class="number">0</span>][Y_train == label]</span><br><span class="line">    plot_y = X_train[:, <span class="number">1</span>][Y_train == label]</span><br><span class="line">    plt.scatter(plot_x, plot_y, c=color, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, label=<span class="string">f&quot;class <span class="subst">&#123;label&#125;</span> train&quot;</span>)</span><br><span class="line">    plot_x = (X_val[:, <span class="number">0</span>][Y_val == label],)</span><br><span class="line">    plot_y = (X_val[:, <span class="number">1</span>][Y_val == label],)</span><br><span class="line">    plt.scatter(plot_x, plot_y, c=color, marker=<span class="string">&quot;^&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, label=<span class="string">f&quot;class <span class="subst">&#123;label&#125;</span> validation&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/./../../images/%E9%A1%B9%E7%9B%AE%E5%9B%BE/%E9%87%8F%E5%AD%90%E7%B4%AB%E8%96%87%E8%8A%B1/Figure_1.png"></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pennylane as qml</span><br><span class="line">from pennylane <span class="keyword">import</span> numpy as np</span><br><span class="line">from pennylane.optimize <span class="keyword">import</span> NesterovMomentumOptimizer</span><br><span class="line">from numpy <span class="keyword">import</span> arcsin</span><br><span class="line"></span><br><span class="line">dev = qml.<span class="built_in">device</span>(<span class="string">&#x27;lightning.qubit&#x27;</span>, wires=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">get_angles</span>(x):</span><br><span class="line">    beta0 = <span class="number">2</span> * np.<span class="built_in">arcsin</span>(np.<span class="built_in">sqrt</span>(x[<span class="number">1</span>] ** <span class="number">2</span>) / np.<span class="built_in">sqrt</span>(x[<span class="number">0</span>] ** <span class="number">2</span> + x[<span class="number">1</span>] ** <span class="number">2</span> + <span class="number">1e-12</span>))</span><br><span class="line">    beta1 = <span class="number">2</span> * np.<span class="built_in">arcsin</span>(np.<span class="built_in">sqrt</span>(x[<span class="number">3</span>] ** <span class="number">2</span>) / np.<span class="built_in">sqrt</span>(x[<span class="number">2</span>] ** <span class="number">2</span> + x[<span class="number">3</span>] ** <span class="number">2</span> + <span class="number">1e-12</span>))</span><br><span class="line">    beta2 = <span class="number">2</span> * np.<span class="built_in">arcsin</span>(np.linalg.<span class="built_in">norm</span>(x[<span class="number">2</span>:]) / np.linalg.<span class="built_in">norm</span>(x))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">array</span>([beta2, -beta1 / <span class="number">2</span>, beta1 / <span class="number">2</span>, -beta0 / <span class="number">2</span>, beta0 / <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">state_preparation</span>(a):</span><br><span class="line">    qml.<span class="built_in">RY</span>(a[<span class="number">0</span>], wires=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    qml.<span class="built_in">CNOT</span>(wires=[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    qml.<span class="built_in">RY</span>(a[<span class="number">1</span>], wires=<span class="number">1</span>)</span><br><span class="line">    qml.<span class="built_in">CNOT</span>(wires=[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    qml.<span class="built_in">RY</span>(a[<span class="number">2</span>], wires=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    qml.<span class="built_in">PauliX</span>(wires=<span class="number">0</span>)</span><br><span class="line">    qml.<span class="built_in">CNOT</span>(wires=[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    qml.<span class="built_in">RY</span>(a[<span class="number">3</span>], wires=<span class="number">1</span>)</span><br><span class="line">    qml.<span class="built_in">CNOT</span>(wires=[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    qml.<span class="built_in">RY</span>(a[<span class="number">4</span>], wires=<span class="number">1</span>)</span><br><span class="line">    qml.<span class="built_in">PauliX</span>(wires=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.<span class="built_in">array</span>([<span class="number">0.53896774</span>, <span class="number">0.79503606</span>, <span class="number">0.27826503</span>, <span class="number">0.0</span>], requires_grad=False)</span><br><span class="line">ang = <span class="built_in">get_angles</span>(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@qml.<span class="built_in">qnode</span>(dev)</span><br><span class="line">def <span class="built_in">test</span>(angles):</span><br><span class="line">    <span class="built_in">state_preparation</span>(angles)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qml.<span class="built_in">state</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">state = <span class="built_in">test</span>(ang)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x               : &quot;</span>, np.<span class="built_in">round</span>(x, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;angles          : &quot;</span>, np.<span class="built_in">round</span>(ang, <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;amplitude vector: &quot;</span>, np.<span class="built_in">round</span>(np.<span class="built_in">real</span>(state), <span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;该方法计算了正确的角度以及准备所需要的态&quot;</span>)</span><br><span class="line"></span><br><span class="line">def <span class="built_in">square_loss</span>(labels, predictions):</span><br><span class="line">    # We use a call to qml.math.stack to allow subtracting the arrays directly</span><br><span class="line">    <span class="keyword">return</span> np.<span class="built_in">mean</span>((labels - qml.math.<span class="built_in">stack</span>(predictions)) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">accuracy</span>(labels, predictions):</span><br><span class="line">    acc = <span class="built_in">sum</span>(<span class="built_in">abs</span>(l - p) &lt; <span class="number">1e-5</span> <span class="keyword">for</span> l, p in <span class="built_in">zip</span>(labels, predictions))</span><br><span class="line">    acc = acc / <span class="built_in">len</span>(labels)</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">layer</span>(layer_weights):</span><br><span class="line">    <span class="keyword">for</span> wire in <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        qml.<span class="built_in">Rot</span>(*layer_weights[wire], wires=wire)</span><br><span class="line">    qml.<span class="built_in">CNOT</span>(wires=[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">cost</span>(weights, bias, X, Y):</span><br><span class="line">    # Transpose the batch of input data in order to make the indexing</span><br><span class="line">    <span class="meta"># in state_preparation work</span></span><br><span class="line">    predictions = <span class="built_in">variational_classifier</span>(weights, bias, X.T)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">square_loss</span>(Y, predictions)</span><br><span class="line"></span><br><span class="line">@qml.<span class="built_in">qnode</span>(dev)</span><br><span class="line">def <span class="built_in">circuit</span>(weights, x):</span><br><span class="line">    <span class="built_in">state_preparation</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> layer_weights in weights:</span><br><span class="line">        <span class="built_in">layer</span>(layer_weights)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> qml.<span class="built_in">expval</span>(qml.<span class="built_in">PauliZ</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="built_in">variational_classifier</span>(weights, bias, x):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">circuit</span>(weights, x) + bias</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = np.<span class="built_in">loadtxt</span>(<span class="string">&quot;iris_classes1and2_scaled.txt&quot;</span>)</span><br><span class="line">X = data[:, <span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;First X sample (original)  : &#123;X[0]&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># pad the vectors to size 2^2=4 with constant values</span></span><br><span class="line">padding = np.<span class="built_in">ones</span>((<span class="built_in">len</span>(X), <span class="number">2</span>)) * <span class="number">0.1</span></span><br><span class="line">X_pad = np.c_[X, padding]</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;First X sample (padded)    : &#123;X_pad[0]&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># normalize each input</span></span><br><span class="line">normalization = np.<span class="built_in">sqrt</span>(np.<span class="built_in">sum</span>(X_pad**<span class="number">2</span>, <span class="number">-1</span>))</span><br><span class="line">X_norm = (X_pad.T / normalization).T</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;First X sample (normalized): &#123;X_norm[0]&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># the angles for state preparation are the features</span></span><br><span class="line">features = np.<span class="built_in">array</span>([<span class="built_in">get_angles</span>(x) <span class="keyword">for</span> x in X_norm], requires_grad=False)</span><br><span class="line"><span class="built_in">print</span>(f<span class="string">&quot;First features sample      : &#123;features[0]&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">Y = data[:, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.<span class="built_in">figure</span>()</span><br><span class="line">plt.<span class="built_in">scatter</span>(X[:, <span class="number">0</span>][Y == <span class="number">1</span>], X[:, <span class="number">1</span>][Y == <span class="number">1</span>], c=<span class="string">&quot;b&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.<span class="built_in">scatter</span>(X[:, <span class="number">0</span>][Y == <span class="number">-1</span>], X[:, <span class="number">1</span>][Y == <span class="number">-1</span>], c=<span class="string">&quot;r&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.<span class="built_in">title</span>(<span class="string">&quot;Original data&quot;</span>)</span><br><span class="line">plt.<span class="built_in">show</span>()</span><br><span class="line"></span><br><span class="line">plt.<span class="built_in">figure</span>()</span><br><span class="line">dim1 = <span class="number">0</span></span><br><span class="line">dim2 = <span class="number">1</span></span><br><span class="line">plt.<span class="built_in">scatter</span>(X_norm[:, dim1][Y == <span class="number">1</span>], X_norm[:, dim2][Y == <span class="number">1</span>], c=<span class="string">&quot;b&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.<span class="built_in">scatter</span>(X_norm[:, dim1][Y == <span class="number">-1</span>], X_norm[:, dim2][Y == <span class="number">-1</span>], c=<span class="string">&quot;r&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.<span class="built_in">title</span>(f<span class="string">&quot;Padded and normalised data (dims &#123;dim1&#125; and &#123;dim2&#125;)&quot;</span>)</span><br><span class="line">plt.<span class="built_in">show</span>()</span><br><span class="line"></span><br><span class="line">plt.<span class="built_in">figure</span>()</span><br><span class="line">dim1 = <span class="number">0</span></span><br><span class="line">dim2 = <span class="number">3</span></span><br><span class="line">plt.<span class="built_in">scatter</span>(features[:, dim1][Y == <span class="number">1</span>], features[:, dim2][Y == <span class="number">1</span>], c=<span class="string">&quot;b&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.<span class="built_in">scatter</span>(features[:, dim1][Y == <span class="number">-1</span>], features[:, dim2][Y == <span class="number">-1</span>], c=<span class="string">&quot;r&quot;</span>, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>)</span><br><span class="line">plt.<span class="built_in">title</span>(f<span class="string">&quot;Feature vectors (dims &#123;dim1&#125; and &#123;dim2&#125;)&quot;</span>)</span><br><span class="line">plt.<span class="built_in">show</span>()</span><br><span class="line"></span><br><span class="line">np.random.<span class="built_in">seed</span>(<span class="number">0</span>)</span><br><span class="line">num_data = <span class="built_in">len</span>(Y)</span><br><span class="line">num_train = <span class="built_in">int</span>(<span class="number">0.75</span> * num_data)</span><br><span class="line">index = np.random.<span class="built_in">permutation</span>(<span class="built_in">range</span>(num_data))</span><br><span class="line">feats_train = features[index[:num_train]]</span><br><span class="line">Y_train = Y[index[:num_train]]</span><br><span class="line">feats_val = features[index[num_train:]]</span><br><span class="line">Y_val = Y[index[num_train:]]</span><br><span class="line"></span><br><span class="line"># We need these later <span class="keyword">for</span> plotting</span><br><span class="line">X_train = X[index[:num_train]]</span><br><span class="line">X_val = X[index[num_train:]]</span><br><span class="line"></span><br><span class="line">num_qubits = <span class="number">2</span></span><br><span class="line">num_layers = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">weights_init = <span class="number">0.01</span> * np.random.<span class="built_in">randn</span>(num_layers, num_qubits, <span class="number">3</span>, requires_grad=True)</span><br><span class="line">bias_init = np.<span class="built_in">array</span>(<span class="number">0.0</span>, requires_grad=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">opt = <span class="built_in">NesterovMomentumOptimizer</span>(<span class="number">0.01</span>)</span><br><span class="line">batch_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># train the variational classifier</span></span><br><span class="line">weights = weights_init</span><br><span class="line">bias = bias_init</span><br><span class="line"><span class="keyword">for</span> it in <span class="built_in">range</span>(<span class="number">60</span>):</span><br><span class="line">    # Update the weights by one optimizer step</span><br><span class="line">    batch_index = np.random.<span class="built_in">randint</span>(<span class="number">0</span>, num_train, (batch_size,))</span><br><span class="line">    feats_train_batch = feats_train[batch_index]</span><br><span class="line">    Y_train_batch = Y_train[batch_index]</span><br><span class="line">    weights, bias, _, _ = opt.<span class="built_in">step</span>(cost, weights, bias, feats_train_batch, Y_train_batch)</span><br><span class="line"></span><br><span class="line">    # 在赋值权重后才可以加入可视化量子电路</span><br><span class="line">    <span class="keyword">if</span> it == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(f<span class="string">&quot;Iteration &#123;it + 1&#125;: Quantum Circuit Visualization:&quot;</span>)</span><br><span class="line">        fig = qml.<span class="built_in">draw_mpl</span>(circuit)(weights, ang)</span><br><span class="line">        plt.<span class="built_in">show</span>()</span><br><span class="line"></span><br><span class="line">    # Compute predictions on train <span class="keyword">and</span> validation set</span><br><span class="line">    predictions_train = np.<span class="built_in">sign</span>(<span class="built_in">variational_classifier</span>(weights, bias, feats_train.T))</span><br><span class="line">    predictions_val = np.<span class="built_in">sign</span>(<span class="built_in">variational_classifier</span>(weights, bias, feats_val.T))</span><br><span class="line"></span><br><span class="line">    # Compute accuracy on train <span class="keyword">and</span> validation set</span><br><span class="line">    acc_train = <span class="built_in">accuracy</span>(Y_train, predictions_train)</span><br><span class="line">    acc_val = <span class="built_in">accuracy</span>(Y_val, predictions_val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (it + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        _cost = <span class="built_in">cost</span>(weights, bias, features, Y)</span><br><span class="line">        <span class="built_in">print</span>(</span><br><span class="line">            f<span class="string">&quot;Iter: &#123;it + 1:5d&#125; | Cost: &#123;_cost:0.7f&#125; | &quot;</span></span><br><span class="line">            f<span class="string">&quot;Acc train: &#123;acc_train:0.7f&#125; | Acc validation: &#123;acc_val:0.7f&#125;&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">plt.<span class="built_in">figure</span>()</span><br><span class="line">cm = plt.cm.RdBu</span><br><span class="line"></span><br><span class="line"><span class="meta"># make data for decision regions</span></span><br><span class="line">xx, yy = np.<span class="built_in">meshgrid</span>(np.<span class="built_in">linspace</span>(<span class="number">0.0</span>, <span class="number">1.5</span>, <span class="number">30</span>), np.<span class="built_in">linspace</span>(<span class="number">0.0</span>, <span class="number">1.5</span>, <span class="number">30</span>))</span><br><span class="line">X_grid = [np.<span class="built_in">array</span>([x, y]) <span class="keyword">for</span> x, y in <span class="built_in">zip</span>(xx.<span class="built_in">flatten</span>(), yy.<span class="built_in">flatten</span>())]</span><br><span class="line"></span><br><span class="line"><span class="meta"># preprocess grid points like data inputs above</span></span><br><span class="line">padding = <span class="number">0.1</span> * np.<span class="built_in">ones</span>((<span class="built_in">len</span>(X_grid), <span class="number">2</span>))</span><br><span class="line">X_grid = np.c_[X_grid, padding]  <span class="meta"># pad each input</span></span><br><span class="line">normalization = np.<span class="built_in">sqrt</span>(np.<span class="built_in">sum</span>(X_grid**<span class="number">2</span>, <span class="number">-1</span>))</span><br><span class="line">X_grid = (X_grid.T / normalization).T  <span class="meta"># normalize each input</span></span><br><span class="line">features_grid = np.<span class="built_in">array</span>([<span class="built_in">get_angles</span>(x) <span class="keyword">for</span> x in X_grid])  <span class="meta"># angles are new features</span></span><br><span class="line">predictions_grid = <span class="built_in">variational_classifier</span>(weights, bias, features_grid.T)</span><br><span class="line">Z = np.<span class="built_in">reshape</span>(predictions_grid, xx.shape)</span><br><span class="line"></span><br><span class="line"><span class="meta"># plot decision regions</span></span><br><span class="line">levels = np.<span class="built_in">arange</span>(<span class="number">-1</span>, <span class="number">1.1</span>, <span class="number">0.1</span>)</span><br><span class="line">cnt = plt.<span class="built_in">contourf</span>(xx, yy, Z, levels=levels, cmap=cm, alpha=<span class="number">0.8</span>, extend=<span class="string">&quot;both&quot;</span>)</span><br><span class="line">plt.<span class="built_in">contour</span>(xx, yy, Z, levels=[<span class="number">0.0</span>], colors=(<span class="string">&quot;black&quot;</span>,), linestyles=(<span class="string">&quot;--&quot;</span>,), linewidths=(<span class="number">0.8</span>,))</span><br><span class="line">plt.<span class="built_in">colorbar</span>(cnt, ticks=[<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta"># plot data</span></span><br><span class="line"><span class="keyword">for</span> color, label in <span class="built_in">zip</span>([<span class="string">&quot;b&quot;</span>, <span class="string">&quot;r&quot;</span>], [<span class="number">1</span>, <span class="number">-1</span>]):</span><br><span class="line">    plot_x = X_train[:, <span class="number">0</span>][Y_train == label]</span><br><span class="line">    plot_y = X_train[:, <span class="number">1</span>][Y_train == label]</span><br><span class="line">    plt.<span class="built_in">scatter</span>(plot_x, plot_y, c=color, marker=<span class="string">&quot;o&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, label=f<span class="string">&quot;class &#123;label&#125; train&quot;</span>)</span><br><span class="line">    plot_x = (X_val[:, <span class="number">0</span>][Y_val == label],)</span><br><span class="line">    plot_y = (X_val[:, <span class="number">1</span>][Y_val == label],)</span><br><span class="line">    plt.<span class="built_in">scatter</span>(plot_x, plot_y, c=color, marker=<span class="string">&quot;^&quot;</span>, ec=<span class="string">&quot;k&quot;</span>, label=f<span class="string">&quot;class &#123;label&#125; validation&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.<span class="built_in">legend</span>()</span><br><span class="line">plt.<span class="built_in">show</span>()</span><br></pre></td></tr></table></figure><h2 id="完整流程图"><a href="#完整流程图" class="headerlink" title="完整流程图"></a>完整流程图</h2><h2 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leecode860柠檬水找零</title>
      <link href="/2024/11/30/%E5%8A%9B%E6%89%A3/Leecode860%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/"/>
      <url>/2024/11/30/%E5%8A%9B%E6%89%A3/Leecode860%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/./../../images/%E9%A2%98%E7%9B%AE%E5%9B%BE/Le860.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>  这道题非常简单，我们目标是实现找零，那么我必然要保证手上时刻都有最多的最小零钱，因为最小零钱可以找散任意零钱。</p><p>可以分一下三种情况讨论</p><p>1.如果是5元零钱，我们直接搜集起来</p><p>2.如果是10元零钱，我们就用5元零钱找散</p><p>3.如果是20元零钱，我们优先使用10元和5元来找散，否则使用3个5元来找散</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计5元，10元</span></span><br><span class="line">        <span class="comment">//5元直接收，10元必须有5元找零，20元必须有10元或5元才能找零</span></span><br><span class="line">        <span class="type">int</span> fiveBill = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> tenBill = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; bills.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(bills[i] == <span class="number">5</span>)  <span class="comment">//5元直接收取</span></span><br><span class="line">            &#123;</span><br><span class="line">                fiveBill++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">10</span>)&#123;  <span class="comment">//10元要判断是否有5元</span></span><br><span class="line">                <span class="keyword">if</span>(fiveBill == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//没有5元钞票就无法找零</span></span><br><span class="line">                <span class="comment">//成功则减少一张5元钞票，增加一张10元钞票                </span></span><br><span class="line">                fiveBill--;</span><br><span class="line">                tenBill++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//20元分两种情况讨论，我们尽可能保留5元钞票</span></span><br><span class="line">                <span class="keyword">if</span>(tenBill &gt; <span class="number">0</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fiveBill &gt; <span class="number">0</span>)  <span class="comment">//第一种用10元和4元</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        tenBill--;</span><br><span class="line">                        fiveBill--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//没有5元无法找散</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(fiveBill &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    fiveBill -= <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 力扣 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Deutsch-Jozsa算法</title>
      <link href="/2024/11/30/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA/Deutsch-Jozsa%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/30/%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA/Deutsch-Jozsa%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Deutsch-Jozsa算法"><a href="#Deutsch-Jozsa算法" class="headerlink" title="Deutsch-Jozsa算法"></a>Deutsch-Jozsa算法</h1><h2 id="1-量子计算并行性"><a href="#1-量子计算并行性" class="headerlink" title="1.量子计算并行性"></a>1.量子计算并行性</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>量子并行性可以是量子计算机可以同时计算函数f(x)在许多不同x处的值</p><h3 id="单量子比特"><a href="#单量子比特" class="headerlink" title="单量子比特"></a>单量子比特</h3><p>设置初态 | x ⟩ | y ⟩的双量子比特计算机，通过合适逻辑门将其转换为 | x ⟩| y⊕ f(x) ⟩</p><p>| x ⟩ :   数据寄存器</p><p>| y ⟩ ： 目标寄存器</p><p>⊕      ： 模2加法</p><p>| x ⟩ | y ⟩ ——＞| x ⟩| y⊕ f(x) ⟩   ： 称为Uf,且是酉算子</p><p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.1/01.png"></p><p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.1/03.png"></p><p>由此，利用量子计算机处于不同状态的叠加能力，单个f（x）路线就可以同时计算多个x值</p><h3 id="多量子比特"><a href="#多量子比特" class="headerlink" title="多量子比特"></a>多量子比特</h3><h4 id="H门推广"><a href="#H门推广" class="headerlink" title="H门推广"></a>H门推广</h4><p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.1/04.png"></p><p>其中，求和是对x的所有可能取值，H变换产生了所有基态的平均叠加态</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.1/05.png"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>由于最后测量时会使得该量子状态坍缩，实际上就等于只计算了一个值。显然，在经典计算机中也是能实现的。对此，Deutsch算法做出对信息的更加好的利用。</p><h2 id="2-Deutsch算法简介"><a href="#2-Deutsch算法简介" class="headerlink" title="2. Deutsch算法简介"></a>2. Deutsch算法简介</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.1/06.png"></p><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.1/07.png"></p><p>如果是f（x）是常值函数，例如f（x）&#x3D; 0，则每个x计算出的结果都是0，那测量结果是|000….00&gt;的概率是100%，否则为非平衡常数。</p><p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.1/08.png"></p><h2 id="3-Deutsch-Jozsa算法"><a href="#3-Deutsch-Jozsa算法" class="headerlink" title="3.Deutsch-Jozsa算法"></a>3.Deutsch-Jozsa算法</h2><p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/%E7%AC%AC%E4%BA%94%E7%AB%A0/5.1/%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B.png"></p>]]></content>
      
      
      <categories>
          
          <category> 量子计算第五章 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分发糖果</title>
      <link href="/2024/11/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/"/>
      <url>/2024/11/30/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/./../images/%E9%A2%98%E7%9B%AE%E5%9B%BE/LE135.png"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不能两边同时考虑，否则会顾此失彼导致两边难以确立，要确定一边孩子的评分后，再确定另一边的</p><ol><li><p>先确定右边孩子的评分大于左边孩子的评分的情况，只要右边孩子的评分比左边孩子的高，那么右边孩子就多得到一颗糖果，从前向后遍历。</p><p>（局部最优：只要右边孩子评分高，那么右边孩子就多拿一个）</p></li><li><p>再确定左边孩子的评分大于右边孩子的评分的情况，从后向前遍历，方便利用之前的比较结果。如果左边孩子变现更优（<strong>记住他在作为右边孩子的时候已经得到更新</strong>），此时需要比较更新后的值与他的右边孩子加一，取其中最大值。</p><p>（局部最优：只要左孩子最优，那么左孩子就拿，CandVec[i+1] + 1和candyVec[i]中的最大值）</p><p><img src="/./../images/%E6%80%9D%E8%B7%AF/LE135.png"></p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">candyVec</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">//从前向后遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; ratings.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i <span class="number">-1</span>]) candyVec[i] = candyVec[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从后向前遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i<span class="number">+1</span>]) candyVec[i] = <span class="built_in">max</span>(candyVec[i], candyVec[i<span class="number">+1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; candyVec.<span class="built_in">size</span>(); i++)</span><br><span class="line">            result += candyVec[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/28/LE134%E5%8A%A0%E6%B2%B9%E7%AB%99/LE134%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
      <url>/2024/11/28/LE134%E5%8A%A0%E6%B2%B9%E7%AB%99/LE134%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/./../../images/%E9%A2%98%E7%9B%AE%E5%9B%BE/LE134.png"></p><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力法思路简单，我们只要模拟环游路径即可</p><p>step1：我们把每个加油站都当做起点，依次从每个起点出发走一圈</p><p>step2：用rest来标记每次的剩余油量，index标记后续位置（要注意index不能越界）,当剩余油量小于0时，则无法走完一圈退出</p><p>step3:  当rest剩余油量&gt;0,同时index&#x3D;&#x3D;i（回到出发点），说明出现一条可以环游一圈的路径，起点为index</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//暴力法</span></span><br><span class="line">        <span class="comment">//把每个加油站当作起点，走一圈，找到能环游一圈的路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> rest = gas[i] - cost[i]; <span class="comment">//记录剩余油量</span></span><br><span class="line">            <span class="type">int</span> index = (i + <span class="number">1</span>) % cost.<span class="built_in">size</span>();  <span class="comment">//记录后续位置</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(rest &gt; <span class="number">0</span> &amp;&amp; index != i) <span class="comment">//模拟以i为起点汽车走一圈的过程</span></span><br><span class="line">            &#123;</span><br><span class="line">                rest += gas[index] - cost[index];</span><br><span class="line">                index = (index + <span class="number">1</span>) % cost.<span class="built_in">size</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果刚好能够跑一圈回到原点</span></span><br><span class="line">            <span class="keyword">if</span>(rest &gt;= <span class="number">0</span> &amp;&amp; i == index) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心法-一-比较难理解，要多回顾"><a href="#贪心法-一-比较难理解，要多回顾" class="headerlink" title="贪心法(一)(比较难理解，要多回顾)"></a>贪心法(一)(比较难理解，要多回顾)</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p>当累计剩余油量大于等于0则必定可以环游一圈，用totalSum来记录</p></li><li><p>环游开始位置start设置为0，依次记录当前的剩余油量</p></li><li><p>当前的剩余油量小于0时，说明[start,i]的这个区间是无法满足环游一圈的，我们更新新的出发位置，从i+1开始重新出发，同时初始化当前的剩余油量为0，再重复向后遍历</p></li><li><p>为什么从i+1开始，而中间的的位置不作考虑，同时也不但心后面出现更大负数</p><p>因为如果可以走一圈，那么必定满足正负抵消使得totalsum&gt;0</p><p>即存在一点开始，使得存在一个如下的图像，整个累计和变化过程在y轴上面</p></li></ol><p><img src="/./../../images/%E6%80%9D%E8%B7%AF/LE134%EF%BC%881%EF%BC%89.png"></p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];  <span class="comment">//记录当前油量</span></span><br><span class="line">            totalSum += gas[i] - cost[i]; <span class="comment">//记录总油量</span></span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) <span class="comment">//如果当前油量小于0，不是抵消的起始点</span></span><br><span class="line">            &#123;</span><br><span class="line">                start = i + <span class="number">1</span>; <span class="comment">//更新我的起始位置</span></span><br><span class="line">                curSum = <span class="number">0</span>; <span class="comment">//重新初始化我的油量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果总累计耗油量小于0，那么必定不可以环绕一圈</span></span><br><span class="line">        <span class="keyword">if</span>(totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>title: LE134加油站<br>date: 2024-11-28 17:31:28<br>tags:</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/Blog\source_posts\每日一题\题目图\LE53.png" alt="logo"></p><p><img src="/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/Blog\source_posts\每日一题\题目图\LE54.png"></p><h2 id="自己的解法-实际上是暴力法"><a href="#自己的解法-实际上是暴力法" class="headerlink" title="自己的解法(实际上是暴力法)"></a>自己的解法(实际上是暴力法)</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>目标：求出一个具有最大和的连续子数组，以[-2, 1,-3, 4, -1, 2, 1，-5,4]为例子</p><p>想法： 不妨从每个元素开始,有[-2, 1,-3, 4, -1, 2,1，-5,4]，[1,-3, 4, -1, 2,1，-5,4]，[-3, 4, -1, 2,1，-5,4]，[ 4, -1, 2,1，-5,4]…[4]，依次有9个子数组，求出每个子数组中的具有最大和的连续子数组。逐一比较后，得到最终的具有最大和的连续子数组。</p><p>操作步骤：</p><p>step1： int maxNum &#x3D; INT_MIN;  &#x2F;&#x2F;标记最大值 ，初始化为一个最小值</p><p>step2:</p><p>1） 第一层for循环相当于标记每个子数组的初始位置</p><p>2） <strong>将第一个子数组的首元素即为sum(也有问题)</strong>,<strong>子序列长度初始化为1（其实这个没啥用，脑子瓦特了）</strong></p><p>​       (ep:<strong>{1} 只有一个元素，MaxNum  &lt; 1 退出循环，直接返回一个最小值</strong>)</p><p>3）从第一个子数组开始，进入第二个for循环，第二个for循环依次遍历后续元素:</p><p>​         <strong>如果sum + 后面一个元素 &lt; MaxNum,, 说明必定不是最大元素，直接退出</strong>(有问题)</p><p>​        ( <strong>ep： <em>[5,4,-1,7,8]     会出现计算到5+4-1时，出现9 &lt; 8 的情况退出，最后返回[7,8]和为15</em></strong></p><p>​           <em><strong>而不是[5,4,-1,7,8]和为5+4-1+7+8&#x3D;23</strong></em>)</p><p>​         否则继续向后遍历，同时更新MaxNum</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从一个新位置开始时，初始化最大值和子数组个数</span></span><br><span class="line">            <span class="type">int</span> sum = nums[i];  </span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//第二层循环是依次遍历起始位置后续值</span></span><br><span class="line">            <span class="comment">//计算最大值和最大连续个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j]; <span class="comment">//更新最大值</span></span><br><span class="line">                <span class="comment">//如果新的最大值大于之前的最大值</span></span><br><span class="line">                <span class="keyword">if</span>(sum &gt; maxNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxNum = sum; <span class="comment">//保存新的最大值</span></span><br><span class="line">                    count++; <span class="comment">//个数加一</span></span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">//退出循环，从下一位置开始</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//没有思路，采用暴力解法</span></span><br><span class="line">        <span class="type">int</span> maxNum = INT_MIN;  <span class="comment">//标记最大值</span></span><br><span class="line">        <span class="comment">//第一层循环用来标记最大子数组和的起始位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从一个新位置开始时，初始化最大值和子数组个数</span></span><br><span class="line">            <span class="type">int</span> sum = nums[i];  </span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//第二层循环是依次遍历起始位置后续值</span></span><br><span class="line">            <span class="comment">//计算最大值和最大连续个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j]; <span class="comment">//更新最大值</span></span><br><span class="line">                <span class="comment">//如果新的最大值大于之前的最大值</span></span><br><span class="line">                <span class="keyword">if</span>(sum &gt; maxNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxNum = sum; <span class="comment">//保存新的最大值</span></span><br><span class="line">                    count++; <span class="comment">//个数加一</span></span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;  <span class="comment">//退出循环，从下一位置开始</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-2,1,-3,4,-1,2,1,-5,4]  答案6    正确</span><br><span class="line">[1]   答案1   错误    结果为-2147483648</span><br><span class="line">[5,4,-1,7,8]    答案23    错误  结果为15</span><br></pre></td></tr></table></figure><p>自己的思路只通过第一个测试点</p><h3 id="思路纠正后的暴力法-超时-时间复杂度高"><a href="#思路纠正后的暴力法-超时-时间复杂度高" class="headerlink" title="思路纠正后的暴力法(超时,时间复杂度高)"></a>思路纠正后的暴力法(超时,时间复杂度高)</h3><h4 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h4><p>2） <strong>将第一个子数组的首元素即为sum(也有问题)</strong>,<strong>子序列长度初始化为1（其实这个没啥用，脑子瓦特了）</strong></p><p>​       (ep:<strong>{1} 只有一个元素，MaxNum  &lt; 1 退出循环，直接返回一个最小值</strong>)</p><p>3）从第一个子数组开始，进入第二个for循环，第二个for循环依次遍历后续元素:</p><p>​         <strong>如果sum + 后面一个元素 &lt; MaxNum,, 说明必定不是最大元素，直接退出</strong>(有问题)</p><p>​        ( <strong>ep： <em>[5,4,-1,7,8]     会出现计算到5+4-1时，出现9 &lt; 8 的情况退出，最后返回[7,8]和为15</em></strong></p><p>​           <em><strong>而不是[5,4,-1,7,8]和为5+4-1+7+8&#x3D;23</strong></em>)</p><h4 id="纠正问题"><a href="#纠正问题" class="headerlink" title="纠正问题"></a>纠正问题</h4><p>step1: 同样定义一个result，用来跟新后续出现的最大值</p><p>step2: </p><ol><li><p>从第一个for循环开始，即循环遍历每一个分解出来的子序列，同时设置变量count记录子序列的累加和</p></li><li><p>进入第二层for循环，从子序列的首元素开始累加，得到的count和result进行比较,记录当中的最大值</p></li><li><p>第二层for循环结束，相当于求出了一个子序列的最大值</p><p> 以[5,4,-1,7,8]为例子</p><p>1] count &#x3D; 5,  5&gt;result,  result &#x3D; 5</p><p>2] count &#x3D; 5 + 4 &#x3D; 9, 9 &gt; result, result &#x3D; 9</p><p>3] count &#x3D; 9 - 1&#x3D;8 , 8 &lt; result, result &#x3D; 9</p><p>4] count &#x3D; 8 + 7 &#x3D; 15, 15 &gt; result,  result &#x3D; 15</p><p>5] count &#x3D; 15 + 8&#x3D; 23, 23 &gt;  result, result &#x3D; 23</p><p>可以得到子序列[5,4,-1,7,8]中的最大和是23</p></li></ol><h4 id="纠正后代码"><a href="#纠正后代码" class="headerlink" title="纠正后代码"></a>纠正后代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一层for循环设置起始位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count = <span class="number">0</span>;  <span class="comment">//从新位置开始时，和初始化为0</span></span><br><span class="line">            <span class="comment">//每次从起始位置i开始遍历寻找最大值  全部求和 然后不断比较新和的值，记录最大的和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                count += nums[j];  <span class="comment">//累加求和</span></span><br><span class="line">                result = count &gt; result ? count : result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>(进入第二层for循环，从子序列的首元素开始累加，得到的count和result进行比较,记录当中的最大值)</p><p>第二个for循环导致时间复杂度，可不可优化？</p><p> 以[-2,1,-3,4,-1,2,1,-5,4]为例子进行观察</p><ol><li>[-2,1]  count &#x3D; -2 +1 &lt; 0  ，从这里开始就已经小于0，猜测以-2开始的子序列最大值不如从下一个元素开始，直接跳入子序列[1,-3,4,-1,2,1,-5,4]。</li><li>[1,-3] 出现1-3&#x3D; -2 &lt; 0, 猜测以1开始的子序列最大值不如从下一个元素开始，直接跳入子序列[-3,4,-1,2,1,-5,4]。</li><li>[-3,4,-1] &#x3D; 0, 猜测以-2开始的子序列最大值不如从下一个元素开始，直接跳入子序列[4,-1,2,1,-5,4]</li><li>[4,-1,2,1,-5,4]中没有小于或等于0的和，则暴力搜索可以得到其中的最大值[4,-1,2,1]&#x3D;6，符合最大解</li><li>猜测成立，说明<strong>局部最大和子序列必须满足累加和大于0</strong>，这一天累计的结果才能推导出全局最优解。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = INT32_MIN;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="comment">//取区间累计的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; result)</span><br><span class="line">            &#123;</span><br><span class="line">                result = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &lt;= <span class="number">0</span>) count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="回顾和总结"><a href="#回顾和总结" class="headerlink" title="回顾和总结"></a>回顾和总结</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/Blog\source_posts\每日一题\题目图\LE55.png"></p><h2 id="贪心思路"><a href="#贪心思路" class="headerlink" title="贪心思路"></a>贪心思路</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h3><p>判断是否能够达到最后一个下标</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><ol><li><p>初步的想法是我可不可以遍历出所有的跳跃方式，然后只要出现一组到达最后一个下标的方式，就返回true，否则返回false</p><p>（会发现这个思路过于复杂，难以实现）</p></li><li><p>到达最后一个下标不妨转化为一个范围问题，只要我的全部跳跃范围覆盖了最后一个下标，那么必定可以到达最后一个下标。</p><p>进一步深入思考，如果我每次选取最大的跳跃范围，只要这些局部最大范围累覆盖最后一个下标，那么必定可以到达最后一个下标，否则最大跳跃范围都无法到达最后一个下标，那么必定失败</p></li></ol><p>​        （这就是贪心所在的地方）</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;  <span class="comment">//初始覆盖范围为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环退出条件</span></span><br><span class="line">        <span class="comment">//当我的跳跃位置到达最大覆盖范围时就可以退出循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cover; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = i + nums[i]; <span class="comment">//记录当前最大的跳跃范围</span></span><br><span class="line">            cover = cover &gt; temp ? cover : temp;  <span class="comment">//跟新最大跳跃范围</span></span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//到达最后一个下标后退出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%882%EF%BC%89/"/>
      <url>/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/../../images/%E9%A2%98%E7%9B%AE%E5%9B%BE/LE45.png"></p><h2 id="自己的思路"><a href="#自己的思路" class="headerlink" title="自己的思路"></a>自己的思路</h2><h3 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h3><p>到达最后一个下标时，要使其跳跃次数最小</p><h3 id="思路：（想简单了）"><a href="#思路：（想简单了）" class="headerlink" title="思路：（想简单了）"></a>思路：（想简单了）</h3><p>第一次可以分不同的跳法</p><p>后续保证每次跳跃是最大范围</p><p>（只能解决示例）</p><h2 id="自己思路代码（超时，有漏洞，只考虑第一步）"><a href="#自己思路代码（超时，有漏洞，只考虑第一步）" class="headerlink" title="自己思路代码（超时，有漏洞，只考虑第一步）"></a>自己思路代码（超时，有漏洞，只考虑第一步）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//起始跳跃有多种方式  但是后面每一步都要跳跃最大</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums[<span class="number">0</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> nextindex = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nextindex = index + nums[index] - i;</span><br><span class="line">                temp++;</span><br><span class="line">                index = nextindex;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="贪心思想"><a href="#贪心思想" class="headerlink" title="贪心思想"></a>贪心思想</h2><h3 id="与跳跃游戏1对比"><a href="#与跳跃游戏1对比" class="headerlink" title="与跳跃游戏1对比"></a>与跳跃游戏1对比</h3><ol><li><p>回顾跳跃游戏1，可得知我们贪心的是最大跳跃范围，然后不断扩大跳跃范围</p></li><li><p>本题也是要求到达最后一个下标，但是要求步数最小</p></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li><p>同样采用最大覆盖范围，但是为了使得步数最小，我们要记录当前跳跃最大范围和下一步的最大跳跃范围</p></li><li><p>我们首先遍历当前最大跳跃范围（在这个范围内，当前位置到达每个下标都只要一步），记录当前最大跳跃范围内的最大下一步跳跃范围（比较第一个位置到达下一个位置后，下一个位置所能产生的最大跳跃范围）</p></li><li><p>当下标位置等于当前最大跳跃范围的最大下标后，我们需要对步数进行更新，可做如下分类讨论</p></li><li><p>如果当前位置已经是最后一个下标值，直接退出循环，步数为1</p></li><li><p>如果小于最后一个下标值，我们需要和下一步最大范围进行比较，更新当前最大范围，同时增加步数</p></li><li><p>重复执行2-5，直至到达最后一个下标为止</p></li></ol><p><img src="/../../images/%E6%80%9D%E8%B7%AF/LE45.png"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> curDistance = <span class="number">0</span>; <span class="comment">//当前最大跳跃范围的下标</span></span><br><span class="line">        <span class="type">int</span> nextDistance = <span class="number">0</span>;  <span class="comment">//下一步最大跳跃范围</span></span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>; <span class="comment">//初始化步数为0</span></span><br><span class="line">        <span class="comment">//注意特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//由于题目给定可以到达最大下标，所以可以遍历所有位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nextDistance = <span class="built_in">max</span>(nextDistance, i + nums[i]); <span class="comment">//更新下一步最大跳跃范围</span></span><br><span class="line">            <span class="comment">//当前位置等与当前最大跳跃范围的下标，更新当前最大跳跃范围的下标</span></span><br><span class="line">            <span class="keyword">if</span>(i == curDistance)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//当前范围最大下标没有到达最后一个下标，所以步数要加一</span></span><br><span class="line">                step++;</span><br><span class="line">                curDistance = nextDistance;  <span class="comment">//当前最大范围由下一步最大范围来更新</span></span><br><span class="line">                <span class="keyword">if</span>(curDistance &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%882%EF%BC%89/"/>
      <url>/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="/2024/11/27/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%882%EF%BC%89/Blog\source_posts\每日一题\题目图\LE122.png"></p><h2 id="自己的解法"><a href="#自己的解法" class="headerlink" title="自己的解法"></a>自己的解法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>目标：获取最大利润</p><p>思路：</p><p>1.为了获取最大利润，自然想到在最低价那天买入，最高价那天抛售</p><p>2.为了判断最高最低价，本人采用了前两天差价和后两天差价作记录</p><p>​     例如[7,1,5,3,6,4]</p><p>​     1-7 &#x3D; -6   5-1 &#x3D; 4  ,于是在1这天购入，5这天抛售</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            preprice = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">            postprice = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">if</span>(postprice &gt; <span class="number">0</span> &amp;&amp; preprice &lt; <span class="number">0</span>)</span><br><span class="line">               result += postprice;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要记录邻近两天股票的差价</span></span><br><span class="line">        <span class="comment">// 负差价时进行购买，正差价时抛出</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">//记录结果</span></span><br><span class="line">        <span class="type">int</span> preprice; <span class="comment">//前两天差价</span></span><br><span class="line">        <span class="type">int</span> postprice;  <span class="comment">//后两天差价</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>() - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            preprice = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">            postprice = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">if</span>(postprice &gt; <span class="number">0</span> &amp;&amp; preprice &lt; <span class="number">0</span>)</span><br><span class="line">               result += postprice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="出现错误"><a href="#出现错误" class="headerlink" title="出现错误"></a>出现错误</h3><p>发现无法解决[1,2,3,4,5]这样连续上涨的问题，难以判断局部最低和最高价，以及全局最低最高价</p><h2 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p>为了获取最大利润，自然想到在最低价那天买入，最高价那天抛售（这条思路没错）</p></li><li><p>既然全局最大利润不好求，我们就拆解为一个一个局部最大利润，那么这些局部最大利润之和就是最大全局利润</p></li><li><p><strong>如何分解</strong>（难点）</p><p>第0天买入，第3天卖出</p><p>prices[3]-prices[0] 等价于(prices[3]-prices[2])+(prices[2]-prices[1])+(prices[1]-prices[0])</p><p>可以发现这几天的利润可以拆分成明天的毛利润之和，为了使利润最大，我们只要计算正数毛利润即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第二天开始</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> price = prices[i] - prices[i<span class="number">-1</span>];  <span class="comment">//计算毛利润</span></span><br><span class="line">    <span class="keyword">if</span>(price &gt; <span class="number">0</span>) result += price;  <span class="comment">//大于0的毛利润就收集起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(temp &gt; <span class="number">0</span>) result += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
