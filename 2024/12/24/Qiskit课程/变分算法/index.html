<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ZTCodeGarden | ZTCodeGarden</title><meta name="author" content="陈智涛"><meta name="copyright" content="陈智涛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="变分算法本课程涵盖了基于量子力学变分定理的变分算法和近期混合量子经典算法的具体内容。这些算法可以利用当今非容错量子计算机提供的实用性，使其成为实现量子优势的理想候选者。 在本课程中，我们将探索： 变分算法设计工作流程中的每个步骤 与每个步骤相关的权衡 如何使用 Qiskit 运行时原语来优化速度和准确性 变分算法包括几个模块化组件，可以根据算法、软件和硬件的进步进行组合和优化。这包括一个用一组参数">
<meta property="og:type" content="article">
<meta property="og:title" content="ZTCodeGarden">
<meta property="og:url" content="http://example.com/2024/12/24/Qiskit%E8%AF%BE%E7%A8%8B/%E5%8F%98%E5%88%86%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="ZTCodeGarden">
<meta property="og:description" content="变分算法本课程涵盖了基于量子力学变分定理的变分算法和近期混合量子经典算法的具体内容。这些算法可以利用当今非容错量子计算机提供的实用性，使其成为实现量子优势的理想候选者。 在本课程中，我们将探索： 变分算法设计工作流程中的每个步骤 与每个步骤相关的权衡 如何使用 Qiskit 运行时原语来优化速度和准确性 变分算法包括几个模块化组件，可以根据算法、软件和硬件的进步进行组合和优化。这包括一个用一组参数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/01.jpg">
<meta property="article:published_time" content="2024-12-24T08:09:23.390Z">
<meta property="article:modified_time" content="2024-12-25T07:32:45.211Z">
<meta property="article:author" content="陈智涛">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/01.jpg"><link rel="shortcut icon" href="/img/02.jpg"><link rel="canonical" href="http://example.com/2024/12/24/Qiskit%E8%AF%BE%E7%A8%8B/%E5%8F%98%E5%88%86%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ZTCodeGarden',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/02.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/01.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ZTCodeGarden</span></a><a class="nav-page-title" href="/"><span class="site-name">ZTCodeGarden</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">无标题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-24T08:09:23.390Z" title="发表于 2024-12-24 16:09:23">2024-12-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-25T07:32:45.211Z" title="更新于 2024-12-25 15:32:45">2024-12-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="变分算法"><a href="#变分算法" class="headerlink" title="变分算法"></a>变分算法</h1><p>本课程涵盖了基于量子力学变分定理的变分算法和近期混合量子经典算法的具体内容。这些算法可以利用当今非容错量子计算机提供的实用性，使其成为实现量子优势的理想候选者。</p>
<p>在本课程中，我们将探索：</p>
<p>变分算法设计工作流程中的每个步骤</p>
<p>与每个步骤相关的权衡</p>
<p>如何使用 Qiskit 运行时原语来优化速度和准确性</p>
<p>变分算法包括几个模块化组件，可以根据算法、软件和硬件的进步进行组合和优化。<strong>这包括一个用一组参数描述特定问题的成本函数、一个用这些参数表达搜索空间的假设和一个迭代探索搜索空间的优化器。在每次迭代过程中，优化器都会使用当前参数评估成本函数，并选择下一次迭代的参数，直到收敛到最优解。这类算法的混合性质来自于这样一个事实：成本函数是使用量子资源评估的，并通过经典资源进行优化。</strong></p>
<ol>
<li><p><strong>初始化问题</strong>：变分算法首先将量子计算机初始化为默认状态∣0⟩，然后将其转换为某个所需（非参数化）状态∣ρ⟩，我们将其称为参考状态。此转换通过在默认状态上应用单一参考运算符UR来表示，这样UR∣0⟩&#x3D;∣ρ⟩。</p>
</li>
<li><p><strong>准备假设</strong>：要从默认状态∣0⟩ 开始迭代优化到目标状态∣ψ(θ)⟩，我们必须定义一个变分形式<br>UV(θ) 来表示一组参数化状态，以供我们的变分算法探索。</p>
<p>我们将参考状态和变分形式的任何特定组合称为假设，例如：UA(θ⃗):&#x3D;UV(θ⃗)URUA(θ):&#x3D;UV(θ)UR。 Ansatze 最终将采用参数化量子电路的形式，能够将默认状态∣0⟩ 转换为目标状态∣ψ(θ⃗⟩<br>∣ψ(θ)⟩。</p>
<p>总而言之，我们将得到：</p>
<p><img src="/2024/12/24/Qiskit%E8%AF%BE%E7%A8%8B/%E5%8F%98%E5%88%86%E7%AE%97%E6%B3%95/Blog\source\images\Qiskit\Day05\01.png"></p>
</li>
<li><p>评估成本函数：<strong>我们可以将问题编码为成本函数C(θ)，作为 Pauli 算子的线性组合，在量子系统上运行。虽然这可以是关于物理系统的信息，例如能量或自旋，但我们也可以编码非物理问题。我们可以利用 Qiskit Runtime 原语在评估成本函数的同时通过错误抑制和缓解来解决噪声问题。</strong></p>
</li>
<li><p>优化参数：评估被带到经典计算机，经典优化器会对其进行分析，并为变分参数选择下一组值。如果我们有一个预先存在的最佳解决方案，我们可以将其设置为初始点θ0来引导我们的优化。使用这个初始状态∣ψ(θ0) 可以帮助我们的优化器更快地找到有效的解决方案。</p>
</li>
<li><p>使用结果调整 ansatz 参数并重新运行：整个过程重复进行，直到满足经典优化器的最终标准，并返回一组最佳参数值θ∗。我们问题的建议解决方案状态将是∣ψ(θ)⟩&#x3D;UA(θ)∣0。</p>
</li>
</ol>
<h2 id="变分定理"><a href="#变分定理" class="headerlink" title="变分定理"></a>变分定理</h2><p>变分算法的一个共同目标是找到具有特定可观测量的最低或最高特征值的量子态。我们将使用的一个关键见解是量子力学的变分定理。在深入探讨其完整表述之前，让我们先探索一下其背后的一些数学直觉。</p>
<h2 id="能量和基态的数学直觉"><a href="#能量和基态的数学直觉" class="headerlink" title="能量和基态的数学直觉"></a>能量和基态的数学直觉</h2><p>能量和基态的数学直觉</p>
<p>在量子力学中，能量以量子可观测量的形式出现，通常称为哈密顿量，我们将用 H 表示。让我们考虑其谱分解：</p>
<p><img src="/./../../images/Qiskit/Day05/02.png"></p>
<p>其中N 是状态空间的维数，λk是k 个特征值，或者物理上是k 个能级，而∣ϕk⟩ 是相应的特征态：<br>H^∣ϕk⟩&#x3D;λk∣ϕk⟩，系统在（标准化）状态∣ψ⟩中的预期能量将为：</p>
<p><img src="/./../../images/Qiskit/Day05/03.png"></p>
<p>如果我们考虑到λ0≤λk,∀k，则我们有：</p>
<p><img src="/./../../images/Qiskit/Day05/04.png"></p>
<h2 id="量子力学的变分定理"><a href="#量子力学的变分定理" class="headerlink" title="量子力学的变分定理"></a>量子力学的变分定理</h2><p><img src="/./../../images/Qiskit/Day05/05.png"></p>
<h1 id="参考状态"><a href="#参考状态" class="headerlink" title="参考状态"></a>参考状态</h1><h2 id="默认状态"><a href="#默认状态" class="headerlink" title="默认状态"></a>默认状态</h2><p>参考状态是指我们问题的初始固定起点。要准备参考状态，我们需要在量子电路的起点应用适当的非参数化幺正UR，这样∣ρ⟩&#x3D;UR∣0⟩。如果您从现有最优解中得到有根据的猜测或数据点，则将其用作起点，变分算法可能会收敛得更快。</p>
<p>最简单的参考状态是默认状态，其中我们使用n 量子比特量子电路的起始状态：∣0⟩⊗n。对于默认状态，我们的幺正运算符UR≡I。由于其简单性，默认状态是许多场景中使用的有效参考状态。</p>
<h2 id="经典参考态"><a href="#经典参考态" class="headerlink" title="经典参考态"></a>经典参考态</h2><p>假设您有一个3 量子比特系统，并且您希望从状态∣001⟩ 开始，而不是默认状态∣000⟩。这是一个纯经典参考状态的示例，要构建它，您只需将 X 门应用于量子比特0（遵循 Qiskit 的量子比特排序），因为∣001⟩&#x3D;X0∣000⟩。</p>
<p>在这种情况下，我们的幺正算子是UR≡X0，这导致参考状态∣ρ⟩≡∣001⟩。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> QuantumCircuit</span><br><span class="line"></span><br><span class="line">qc = QuantumCircuit(<span class="number">3</span>)</span><br><span class="line">qc.x(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">qc.draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f1.png" alt="img"></p>
<h2 id="量子参考态"><a href="#量子参考态" class="headerlink" title="量子参考态"></a>量子参考态</h2><p>假设您打算从涉及叠加和&#x2F;或纠缠的更复杂状态开始，例如<br>$$<br>\frac{1}{\sqrt2}(∣100⟩+∣111⟩)<br>$$<br>要从∣000⟩ 获得此状态，一种方法是在量子位0 上使用 Hadamard 门 (H0)，以量子位<br>0 作为控制量子位、以量子位1 作为目标量子位的 CNOT (CX) 门 (CNOT01)，最后将<br>X 门应用于量子位2 (X2)。</p>
<p>在这种情况下，我们的幺正算子是<strong>UR≡X2CNOT01H0∣000⟩</strong>，我们的参考状态是∣ρ⟩≡</p>
<p>$$<br>\frac{1}{\sqrt2}(∣100⟩+∣111⟩)<br>$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qc = QuantumCircuit(<span class="number">3</span>)</span><br><span class="line">qc.h(<span class="number">0</span>)</span><br><span class="line">qc.cx(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">qc.x(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">qc.draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f2.png" alt="img"></p>
<h2 id="使用模板电路构建参考状态"><a href="#使用模板电路构建参考状态" class="headerlink" title="使用模板电路构建参考状态"></a>使用模板电路构建参考状态</h2><p>我们还可以使用各种模板电路，例如TwoLocal，它可以轻松表达多个可调参数和纠缠。我们将在下一课中更详细地介绍这些模板电路，但如果我们绑定参数，我们可以将它们用作参考状态。：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.circuit.library <span class="keyword">import</span> TwoLocal</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"></span><br><span class="line">reference_circuit = TwoLocal(<span class="number">2</span>, <span class="string">&quot;rx&quot;</span>, <span class="string">&quot;cz&quot;</span>, entanglement=<span class="string">&quot;linear&quot;</span>, reps=<span class="number">1</span>)</span><br><span class="line">theta_list = [pi / <span class="number">2</span>, pi / <span class="number">3</span>, pi / <span class="number">3</span>, pi / <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">reference_circuit = reference_circuit.assign_parameters(theta_list)</span><br><span class="line"></span><br><span class="line">reference_circuit.decompose().draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f3.png" alt="img"></p>
<h2 id="特定于应用程序的参考状态"><a href="#特定于应用程序的参考状态" class="headerlink" title="特定于应用程序的参考状态"></a>特定于应用程序的参考状态</h2><h3 id="量子机器学习"><a href="#量子机器学习" class="headerlink" title="量子机器学习"></a>量子机器学习</h3><p>在变分量子分类器 (VQC) 中，训练数据通过参数化电路（称为特征图）编码为量子态，其中每个参数值代表来自训练数据集的一个数据点。ZZFeatureMap 是一种参数化电路，可用于将我们的数据点 (x) 传递到此特征图。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.circuit.library <span class="keyword">import</span> ZZFeatureMap</span><br><span class="line"></span><br><span class="line">data = [<span class="number">0.1</span>, <span class="number">0.2</span>]</span><br><span class="line"></span><br><span class="line">zz_feature_map_reference = ZZFeatureMap(feature_dimension=<span class="number">2</span>, reps=<span class="number">2</span>)</span><br><span class="line">zz_feature_map_reference = zz_feature_map_reference.assign_parameters(data)</span><br><span class="line">zz_feature_map_reference.decompose().draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f4.png"></p>
<h1 id="拟定形式和变分形式"><a href="#拟定形式和变分形式" class="headerlink" title="拟定形式和变分形式"></a>拟定形式和变分形式</h1><h2 id="参数化量子电路"><a href="#参数化量子电路" class="headerlink" title="参数化量子电路"></a>参数化量子电路</h2><p>变分算法通过探索和比较一系列量子态∣ψ(θ)⟩ 来运行，这些量子态取决于一组有限的k 参数θ&#x3D;(θ0,…,θk)。这些状态可以使用参数化量子电路来准备，其中门是用可调参数定义的。可以创建这个参数化电路而无需绑定特定角度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.circuit <span class="keyword">import</span> QuantumCircuit, Parameter</span><br><span class="line"></span><br><span class="line">theta = Parameter(<span class="string">&quot;θ&quot;</span>)</span><br><span class="line"></span><br><span class="line">qc = QuantumCircuit(<span class="number">3</span>)</span><br><span class="line">qc.rx(theta, <span class="number">0</span>)</span><br><span class="line">qc.cx(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">qc.x(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">qc.draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f5.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line"></span><br><span class="line">angle_list = [pi / <span class="number">3</span>, pi / <span class="number">2</span>]</span><br><span class="line">circuits = [qc.assign_parameters(&#123;theta: angle&#125;) <span class="keyword">for</span> angle <span class="keyword">in</span> angle_list]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> circuit <span class="keyword">in</span> circuits:</span><br><span class="line">    display(circuit.draw(<span class="string">&quot;mpl&quot;</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f6.png"></p>
<h2 id="变分形式和假设"><a href="#变分形式和假设" class="headerlink" title="变分形式和假设"></a>变分形式和假设</h2><p>为了从参考状态∣ρ⟩ 迭代优化到目标状态∣ψ(θ)⟩，我们需要定义一个变分形式<br>UV(θ)，它表示一组参数化状态，供我们的变分算法探索：</p>
<p><img src="/./../../images/Qiskit/Day05/a1.png"></p>
<p>请注意，参数化状态既依赖于参考状态∣ρ⟩（不依赖于任何参数），也依赖于变分形式UV(θ)（始终依赖于参数）。我们将这两部分的组合称为拟设：UA(θ):&#x3D;UV(θ)UR。</p>
<p>当我们构建拟设来表示一组参数化状态以供变分算法探索时，我们意识到一个重要问题：维数。n 量子比特系统（即希尔伯特空间）在配置空间中具有大量不同的量子态。我们需要大量的参数才能充分探索它。从数量上讲，它的维数为D&#x3D;2^2n。更糟糕的是，搜索算法和其他类似算法的运行时复杂度会随着这种维数的增加而呈指数增长，这种现象在文献中通常被称为维数灾难。</p>
<p>为了应对这一挫折，通常的做法是对变分形式施加一些合理的约束，以便只探索最相关的状态。寻找有效的截断假设是一个活跃的研究领域，但我们将介绍两种常见的设计。</p>
<h3 id="启发式分析和权衡"><a href="#启发式分析和权衡" class="headerlink" title="启发式分析和权衡"></a>启发式分析和权衡</h3><p>如果您没有关于特定问题的任何信息来帮助限制维度，您可以尝试使用少于2^2n个参数的任意参数化电路系列。但是，需要考虑一些权衡：</p>
<p><strong>速度</strong>：通过减少搜索空间，算法可以运行得更快。<br><strong>准确性</strong>：但是，减少空间可能会排除问题的实际解决方案，从而导致次优解决方案。<br><strong>噪声</strong>：更深的电路会受到噪声的影响，因此我们需要试验我们的 ansatz 的连接性、门和门保真度。<br>质量（甚至可解性）和速度之间存在根本的权衡：参数越多，找到精确结果的可能性就越大，但运行算法所需的时间越长。</p>
<h4 id="N-局部电路"><a href="#N-局部电路" class="headerlink" title="N 局部电路"></a>N 局部电路</h4><p>启发式假设最广泛使用的例子之一是 N 局部电路，原因如下：</p>
<p>高效实施：N 局部假设通常由简单的局部门组成，可以使用少量物理量子比特在量子计算机上高效实现。这使得构建和优化量子电路变得更加容易。<br>捕获重要相关性：N 局部假设可以捕获量子系统中量子比特之间的重要相关性，即使门数量很少。这是因为局部门可以作用于相邻的量子比特并在它们之间产生纠缠，这对于模拟复杂的量子系统非常重要。<br>这些电路由旋转和纠缠层组成，它们交替重复一次或多次，如下所示：</p>
<p>每层由大小最多为N 的门组成，其中N 必须低于量子比特的数量。</p>
<p>对于旋转层，门堆叠在一起。我们可以使用标准旋转操作，例如RX或CRZ。<br>对于纠缠层，我们可以使用像Toffoli门或CX这样的门，并采用纠缠策略。</p>
<p>两种类型的层都可以参数化或不参数化，但至少其中一个需要包含参数。否则，如果没有至少一个参数，就不会有任何变化！<br>可选地，在电路末端添加一个额外的旋转层。</p>
<p>例如，让我们创建一个5 量子比特NLocal电路，其中旋转块由RX和CRZ门形成，纠缠块由Toffoli门形成，作用于量子比特[0,1,2],[0,2,3],[4,2,1] 和[3,1,0] 和每层重复 2 次。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.circuit.library <span class="keyword">import</span> NLocal, CCXGate, CRZGate, RXGate</span><br><span class="line"><span class="keyword">from</span> qiskit.circuit <span class="keyword">import</span> Parameter</span><br><span class="line"></span><br><span class="line">theta = Parameter(<span class="string">&quot;θ&quot;</span>)</span><br><span class="line">ansatz = NLocal(</span><br><span class="line">    num_qubits=<span class="number">5</span>,</span><br><span class="line">    rotation_blocks=[RXGate(theta), CRZGate(theta)],</span><br><span class="line">    entanglement_blocks=CCXGate(),</span><br><span class="line">    entanglement=[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]],</span><br><span class="line">    reps=<span class="number">2</span>,</span><br><span class="line">    insert_barriers=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">ansatz.decompose().draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f7.png"></p>
<p>在上面的例子中，最大的门是 Toffoli 门，它作用于三个量子比特，使电路成为3 局部电路。最常用的N 局部电路类型是2局部电路，具有单量子比特旋转门和2 量子比特纠缠门。</p>
<p>让我们使用 Qiskit 的TwoLocal类创建一个2 局部电路。语法与 NLocal 相同，但有一些区别。例如，大多数门（如 RX、RZ 和 CNOT）都可以作为字符串传递，而无需导入门或创建 Parameter 实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.circuit.library <span class="keyword">import</span> TwoLocal</span><br><span class="line"></span><br><span class="line">ansatz = TwoLocal(</span><br><span class="line">    num_qubits=<span class="number">5</span>,</span><br><span class="line">    rotation_blocks=[<span class="string">&quot;rx&quot;</span>, <span class="string">&quot;rz&quot;</span>],</span><br><span class="line">    entanglement_blocks=<span class="string">&quot;cx&quot;</span>,</span><br><span class="line">    entanglement=<span class="string">&quot;linear&quot;</span>,</span><br><span class="line">    reps=<span class="number">2</span>,</span><br><span class="line">    insert_barriers=<span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line">ansatz.decompose().draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f8.png"></p>
<p>在这种情况下，我们使用了线性纠缠分布，其中每个量子比特都与下一个量子比特纠缠在一起。要了解其他策略，请参阅TwoLocal的文档。</p>
<h4 id="高效SU2"><a href="#高效SU2" class="headerlink" title="高效SU2"></a>高效SU2</h4><p>EfficientSU2是一种硬件高效的电路，由跨越 SU(2) 和 CX 纠缠的单量子比特操作层组成。这是一种启发式模式，可用于为变分量子算法准备试验波函数或作为机器学习的<strong>分类电路</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.circuit.library <span class="keyword">import</span> EfficientSU2</span><br><span class="line"></span><br><span class="line">ansatz = EfficientSU2(<span class="number">4</span>, su2_gates=[<span class="string">&quot;rx&quot;</span>, <span class="string">&quot;y&quot;</span>], entanglement=<span class="string">&quot;linear&quot;</span>, reps=<span class="number">1</span>)</span><br><span class="line">ansatz.decompose().draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f9.png"></p>
<h3 id="问题特定的假设"><a href="#问题特定的假设" class="headerlink" title="问题特定的假设"></a>问题特定的假设</h3><p>虽然启发式和硬件高效的假设可以帮助我们以简单的方式解决问题，但我们可以使用问题特定的知识将电路搜索空间限制为特定类型。这将帮助我们在搜索过程中提高速度而不损失准确性。</p>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>在最大割问题中，我们希望以一种最大化不同组节点之间边数的方式来划分图中的节点。下图所需的最大割划分很明确：左侧的第 0 个节点应通过割线与右侧的其余节点分开。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> rustworkx <span class="keyword">as</span> rx</span><br><span class="line"><span class="keyword">from</span> rustworkx.visualization <span class="keyword">import</span> mpl_draw</span><br><span class="line"></span><br><span class="line">n = <span class="number">4</span></span><br><span class="line">G = rx.PyGraph()</span><br><span class="line">G.add_nodes_from(<span class="built_in">range</span>(n))</span><br><span class="line"><span class="comment"># The edge syntax is (start, end, weight)</span></span><br><span class="line">edges = [(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1.0</span>), (<span class="number">0</span>, <span class="number">2</span>, <span class="number">1.0</span>), (<span class="number">0</span>, <span class="number">3</span>, <span class="number">1.0</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">1.0</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1.0</span>)]</span><br><span class="line">G.add_edges_from(edges)</span><br><span class="line"></span><br><span class="line">mpl_draw(G, pos=rx.shell_layout(G), with_labels=<span class="literal">True</span>, edge_labels=<span class="built_in">str</span>, node_color=<span class="string">&quot;#1192E8&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f10.png"></p>
<p>要利用 QAOA 算法解决最大割问题，我们需要一个泡利哈密顿量，它以某种方式对成本进行编码，使得运算符的最小期望值对应于两个不同组中节点之间的最大边数。</p>
<p>对于这个简单的例子，运算符是边连接的节点上 Z 运算符的项的线性组合（回想一下，第 0 个量子位最右边）：ZZII+IZZI+ZIIZ+IZIZ+IIZZ。构造运算符后，可以使用 Qiskit 电路库中的 QAOAAnsatz 电路轻松构建 QAOA 算法的假设。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pre-defined ansatz circuit, operator class and visualization tools</span></span><br><span class="line"><span class="keyword">from</span> qiskit.circuit.library <span class="keyword">import</span> QAOAAnsatz</span><br><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span> SparsePauliOp</span><br><span class="line"></span><br><span class="line"><span class="comment"># Problem to Hamiltonian operator</span></span><br><span class="line">hamiltonian = SparsePauliOp.from_list([(<span class="string">&quot;ZZII&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;IZZI&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;ZIIZ&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;IZIZ&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;IIZZ&quot;</span>, <span class="number">1</span>)])</span><br><span class="line"><span class="comment"># QAOA ansatz circuit</span></span><br><span class="line">ansatz = QAOAAnsatz(hamiltonian, reps=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Draw</span></span><br><span class="line">ansatz.decompose(reps=<span class="number">3</span>).draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f11.png"></p>
<p>为了清晰起见，上图以基本门的形式展示了假设。但是，可以通过更改 reps 参数或绘制不使用分解方法的电路来以多层分解表示。例如，以下表示直接显示了具有默认 reps 值的 QAOA 结构，即 reps&#x3D;1 。</p>
<h4 id="量子机器学习-1"><a href="#量子机器学习-1" class="headerlink" title="量子机器学习"></a>量子机器学习</h4><p>在机器学习中，一种常见的应用是将数据分为两个或多个类别。这涉及将数据点编码到特征图中，该特征图将经典特征向量映射到量子希尔伯特空间中。基于难以经典模拟的参数化量子电路构建量子特征图是获得优于经典机器学习方法的潜在优势的重要一步，也是当前研究的一个活跃领域。</p>
<p>ZZFeatureMap 可用于创建参数化电路。我们可以将数据点传递给特征图 (x) 和一个单独的变分形式，以将权重作为参数传递 (θ)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.circuit.library <span class="keyword">import</span> ZZFeatureMap, TwoLocal</span><br><span class="line"></span><br><span class="line">data = [<span class="number">0.1</span>, <span class="number">0.2</span>]</span><br><span class="line"></span><br><span class="line">zz_feature_map_reference = ZZFeatureMap(feature_dimension=<span class="number">2</span>, reps=<span class="number">2</span>)</span><br><span class="line">zz_feature_map_reference = zz_feature_map_reference.assign_parameters(data)</span><br><span class="line"></span><br><span class="line">variation_form = TwoLocal(<span class="number">2</span>, [<span class="string">&quot;ry&quot;</span>, <span class="string">&quot;rz&quot;</span>], <span class="string">&quot;cz&quot;</span>, reps=<span class="number">2</span>)</span><br><span class="line">vqc_ansatz = zz_feature_map_reference.compose(variation_form)</span><br><span class="line">vqc_ansatz.decompose().draw(<span class="string">&quot;mpl&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day05/f12.png"></p>
<h1 id="Cost-Functions"><a href="#Cost-Functions" class="headerlink" title="Cost Functions"></a>Cost Functions</h1><h2 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h2><p>所有物理系统，无论是经典系统还是量子系统，都可以存在于不同的状态中。例如，道路上的汽车可以具有表征其状态的特定质量、位置、速度或加速度。同样，量子系统也可以具有不同的配置或状态，但它们在处理测量和状态演变的方式上与经典系统不同。这导致了量子力学独有的叠加和纠缠等独特属性。就像我们可以用速度或加速度等物理属性来描述汽车的状态一样，<strong>我们也可以使用可观测量来描述量子系统的状态，可观测量是数学对象。</strong></p>
<p>在量子力学中，状态由归一化复列向量或 kets (∣ψ⟩) 表示，可观测量是作用于 kets 的厄米线性算子 (<br>H^&#x3D;H^†)。可观测量的特征向量 (∣λ⟩) 称为特征态。测量可观测量的其中一个特征态 (∣λ⟩) 将为我们提供相应的特征值 (λ) 作为读数。</p>
<p>如果您想知道如何测量量子系统以及可以测量什么，Qiskit 提供了两个可以提供帮助的原语：</p>
<p>采样器：给定一个量子态∣ψ⟩，此原语可获得每个可能的计算基础状态的概率。<br>估计器：给定一个量子可观测量H^和一个状态∣ψ⟩，此原语可计算H^的预期值。</p>
<h3 id="采样器原语"><a href="#采样器原语" class="headerlink" title="采样器原语"></a>采样器原语</h3><p><strong>采样器原语计算从计算基础获得每个可能状态的概率∣k⟩</strong>，给定一个准备状态的量子电路∣ψ⟩。它计算</p>
<p><img src="/./../../images/Qiskit/Day06/01.png"></p>
<p>其中n 是量子比特的数量，k 是任何可能输出二进制字符串的整数表示{0,1}^n(即以2 为基数的整数）。</p>
<p>Qiskit Runtime 的采样器在量子设备上运行电路多次，每次运行时执行测量，并从恢复的位串中重建概率分布。它执行的运行次数（或采样次数）越多，结果就越准确，但这需要更多的时间和量子资源。</p>
<p>但是，由于可能的输出数量随着量子比特的数量n（即2^n）呈指数增长，因此采样次数也需要呈指数增长才能捕获密集的概率分布。因此，采样器仅对稀疏概率分布有效；其中目标状态∣ψ⟩ 必须可以表示为计算基础状态的线性组合，其中项的数量最多随量子比特的数量呈多项式增长：</p>
<p><img src="/./../../images/Qiskit/Day06/02.png"></p>
<p>采样器还可以配置为从电路的某个子部分检索概率，代表所有可能状态的子集。</p>
<h3 id="估算器原语"><a href="#估算器原语" class="headerlink" title="估算器原语"></a>估算器原语</h3><p><strong>估计器原语计算量子态∣ψ⟩ 的可观测量H^的期望值；</strong>其中可观测量概率可以表示为pλ&#x3D;∣⟨λ∣ψ⟩∣^2，即<br>∣λ⟩ 是可观测量H^的特征态。然后，期望值被定义为状态∣ψ⟩ 测量的所有可能结果λ（即可观测量的特征值）的平均值，并按相应的概率加权：</p>
<p><img src="/./../../images/Qiskit/Day06/03.png"></p>
<p><strong>但是，计算可观测量的期望值并不总是可行的，因为我们通常不知道它的特征基。</strong>Qiskit Runtime 的 Estimator 使用复杂的代数过程来估计真实量子设备上的期望值，方法是将可观测量分解为我们知道其特征基的其他可观测量的组合。</p>
<p>简而言之，Estimator 将它不知道如何测量的任何可观测量分解为更简单、可测量的可观测量，称为 Pauli 算子。</p>
<p>任何算子都可以表示为4^n个 Pauli 算子的组合。</p>
<p><img src="/./../../images/Qiskit/Day06/04.png"></p>
<p>例如</p>
<p><img src="/./../../images/Qiskit/Day06/05.png"></p>
<p><img src="/./../../images/Qiskit/Day06/06.png"></p>
<p>执行此分解后，估算器会为每个可观测量P^k（即来自原始电路）导出一个新的电路Vk∣ψ⟩，从而有效地在计算基础中对角化 Pauli 可观测量并对其进行测量。我们可以轻松测量 Pauli 可观测量，因为我们提前知道Vk，而其他可观测量通常并非如此。</p>
<p>对于每个P^k，估算器会在量子设备上多次运行相应的电路，在计算基础中测量输出状态，并计算获得每个可能输出j 的概率pkj。然后，它查找对应于每个输出j 的Pk的特征值λkj，乘以wk，然后将所有结果相加，以获得给定状态|ψ⟩ 的可观测量H^的预期值。</p>
<p><img src="/./../../images/Qiskit/Day06/07.png"></p>
<p>由于计算4^nPaulis 的期望值不切实际（即呈指数增长），因此只有当大量wk为零（即稀疏 Pauli 分解而不是密集 Pauli 分解）时，Estimator 才有效。正式地说，为了使此计算有效可解，非零项的数量必须随量子比特数n 最多多项式增长：</p>
<p><img src="/./../../images/Qiskit/Day06/08.png"></p>
<p>读者可能会注意到隐含的假设，即概率抽样也需要有效，如 Sampler 所解释的那样，这意味着</p>
<p><img src="/./../../images/Qiskit/Day06/09.png"></p>
<h3 id="计算期望值的指导示例"><a href="#计算期望值的指导示例" class="headerlink" title="计算期望值的指导示例"></a>计算期望值的指导示例</h3><p>假设单量子比特状态∣+⟩:&#x3D;H∣0⟩&#x3D;1&#x2F;sqrt(2)(∣0⟩+∣1⟩)，并且可观察</p>
<p><img src="/./../../images/Qiskit/Day06/10.png"></p>
<p>理论期望值如下</p>
<p><img src="/./../../images/Qiskit/Day06/11.png"></p>
<p>由于我们不知道如何测量这个可观测量，我们无法直接计算它的期望值，我们需要将其重新表示为<br>⟨H^⟩+&#x3D;2⟨X⟩+ − ⟨Z⟩。可以通过注意到⟨+∣X∣+⟩&#x3D;1，以及⟨+∣Z∣+⟩&#x3D;0 来证明其计算结果相同。</p>
<p>让我们看看如何直接计算⟨X⟩+和⟨Z⟩+。由于X 和Z 不交换（即不共享相同的特征基），因此无法同时测量它们，因此我们需要辅助电路：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> QuantumCircuit</span><br><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span>  SparsePauliOp</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单比特</span></span><br><span class="line">original_circuit = QuantumCircuit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 施加H门变换</span></span><br><span class="line">original_circuit.h(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可观测量基H 拆分为H = 2X - Z</span></span><br><span class="line">H = SparsePauliOp([<span class="string">&quot;X&quot;</span>, <span class="string">&quot;Z&quot;</span>], [<span class="number">2</span>, -<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">aux_circuits = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pauli <span class="keyword">in</span> H.paulis:</span><br><span class="line">    aux_circ = original_circuit.copy()  <span class="comment"># 保存原电路</span></span><br><span class="line">    aux_circ.barrier()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(pauli) == <span class="string">&quot;X&quot;</span>:</span><br><span class="line">        aux_circ.h(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">str</span>(pauli) == <span class="string">&quot;Y&quot;</span>:</span><br><span class="line">        aux_circ.sdg(<span class="number">0</span>)</span><br><span class="line">        aux_circ.h(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        aux_circ.<span class="built_in">id</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    aux_circ.measure_all()</span><br><span class="line">    aux_circuits.append(aux_circ)</span><br><span class="line"></span><br><span class="line">original_circuit.draw(<span class="string">&quot;mpl&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day06/f1.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auxiliary circuit for X</span></span><br><span class="line">aux_circuits[<span class="number">0</span>].draw(<span class="string">&#x27;mpl&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day06/f2.png"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auxiliary circuit for Z</span></span><br><span class="line">aux_circuits[<span class="number">1</span>].draw(<span class="string">&#x27;mpl&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day06/f3.png"></p>
<p>我们现在可以使用 Sampler 手动进行计算并在 Estimator 上检查结果：</p>
<h4 id="一个完整的实验"><a href="#一个完整的实验" class="headerlink" title="一个完整的实验"></a>一个完整的实验</h4><ol>
<li><strong>StatevectorSampler（采样器）方法</strong></li>
</ol>
<p><code>StatevectorSampler</code> 用于模拟量子态向量的测量结果并进行采样。你进行了以下步骤：</p>
<ul>
<li><p><strong>shots &#x3D; 10000</strong>：你设置了每次运行量子电路的采样次数（shots）。</p>
</li>
<li><p>**sampler.run(aux_circuits, shots&#x3D;shots)**：运行量子电路 <code>aux_circuits</code>（你应该在代码的其他地方定义了这个电路），并进行测量。</p>
</li>
<li><p><strong>quasi_dist</strong>：基于测量的比特字符串的计数，计算准分布并通过总的采样次数进行归一化。</p>
</li>
<li><p><strong>expvals</strong>：对于每个 Pauli 操作符（<code>I</code>、<code>X</code>、<code>Y</code>、<code>Z</code>），你根据准分布计算其期望值。</p>
<p>在这个循环中：</p>
<ul>
<li>使用对应的门矩阵（<code>IGate</code>、<code>XGate</code>、<code>ZGate</code>、<code>YGate</code>）来表示每个 Pauli 操作符。</li>
<li>对于 <code>X</code> 和 <code>Y</code>，你手动计算了测量结果（<code>0</code> 和 <code>1</code>）对期望值的贡献。</li>
<li>对于 <code>Z</code>，期望值的计算较为直接。</li>
</ul>
</li>
<li><p><strong>total_expval</strong>：通过将哈密顿量的系数（<code>H.coeffs</code>）作为权重，计算所有单独期望值的加权和，得到总期望值。</p>
</li>
</ul>
<ol start="2">
<li><strong>StatevectorEstimator（估算器）方法</strong></li>
</ol>
<p><code>StatevectorEstimator</code> 直接计算基于量子态向量的可观测量的期望值（包括全局的哈密顿量和单独的 Pauli 操作符）。</p>
<ul>
<li>**observables &#x3D; [*H.paulis, H]**：你定义了一个包含单个 Pauli 操作符（<code>H.paulis</code>）和完整哈密顿量（<code>H</code>）的可观测量列表。</li>
<li>**estimator.run([(original_circuit, observables)])**：对给定的量子电路 <code>original_circuit</code> 和可观测量列表运行估算器。</li>
<li><strong>estimator_expvals</strong>：估算器返回的结果是每个可观测量的期望值。</li>
</ul>
<p>需</p>
<p>最终思路：</p>
<p>你的代码结构基本正确，但需要确保量子电路、可观测量和哈密顿量被正确定义，并且期望值的计算是准确的。<strong>StatevectorSampler</strong> 和 <strong>StatevectorEstimator</strong> 应该能够按预期工作，但小的调整（例如修复 <code>YGate</code> 的使用）可以帮助确保计算更加精确。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.primitives <span class="keyword">import</span> StatevectorSampler, StatevectorEstimator</span><br><span class="line"><span class="keyword">from</span> qiskit.result <span class="keyword">import</span> QuasiDistribution</span><br><span class="line"><span class="keyword">from</span> qiskit.circuit.library <span class="keyword">import</span> IGate, ZGate, XGate, YGate</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## SAMPLER</span></span><br><span class="line">shots = <span class="number">10000</span></span><br><span class="line">sampler = StatevectorSampler()</span><br><span class="line">job = sampler.run(aux_circuits, shots = shots)</span><br><span class="line">data_pub = job.result()[<span class="number">1</span>].data</span><br><span class="line">bitstrings = data_pub.meas.get_bitstrings()</span><br><span class="line">counts = data_pub.meas.get_counts()</span><br><span class="line">quasi_dist = QuasiDistribution(&#123;outcome: freq / shots <span class="keyword">for</span> outcome, freq <span class="keyword">in</span> counts.items()&#125;)</span><br><span class="line"></span><br><span class="line">expvals = []</span><br><span class="line"><span class="keyword">for</span> pauli <span class="keyword">in</span> H.paulis:</span><br><span class="line">    val = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(pauli) == <span class="string">&quot;I&quot;</span>:</span><br><span class="line">        Lambda = IGate().to_matrix().real</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(pauli) == <span class="string">&quot;X&quot;</span>:</span><br><span class="line">        Lambda = XGate().to_matrix().real</span><br><span class="line">        val += Lambda[<span class="number">0</span>][<span class="number">1</span>] * quasi_dist.get(<span class="number">1</span>)</span><br><span class="line">        val += Lambda[<span class="number">1</span>][<span class="number">0</span>] * quasi_dist.get(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(pauli) == <span class="string">&quot;Y&quot;</span>:</span><br><span class="line">        Lambda = XGate().to_matrix().real</span><br><span class="line">        val += Lambda[<span class="number">0</span>][<span class="number">1</span>] * <span class="number">1.j</span> * quasi_dist.get(<span class="number">1</span>)</span><br><span class="line">        val += Lambda[<span class="number">1</span>][<span class="number">0</span>] * -<span class="number">1.j</span> * quasi_dist.get(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">str</span>(pauli) == <span class="string">&quot;Z&quot;</span>:</span><br><span class="line">        Lambda = ZGate().to_matrix().real</span><br><span class="line">        val += Lambda[<span class="number">0</span>][<span class="number">0</span>] * quasi_dist.get(<span class="number">0</span>)</span><br><span class="line">        val += Lambda[<span class="number">1</span>][<span class="number">1</span>] * quasi_dist.get(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    expvals.append(val)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sampler results:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (pauli, expval) <span class="keyword">in</span> <span class="built_in">zip</span>(H.paulis, expvals):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;  &gt;&gt; Expected value of <span class="subst">&#123;<span class="built_in">str</span>(pauli)&#125;</span>: <span class="subst">&#123;expval:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">total_expval = np.<span class="built_in">sum</span>(H.coeffs * expvals).real</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;  &gt;&gt; Total expected value: <span class="subst">&#123;total_expval:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## ESTIMATOR</span></span><br><span class="line">observables = [</span><br><span class="line">    *H.paulis,H</span><br><span class="line">]  <span class="comment"># Note: run for individual Paulis as well as full observable H</span></span><br><span class="line"></span><br><span class="line">estimator = StatevectorEstimator()</span><br><span class="line">job = estimator.run([(original_circuit, observables)])</span><br><span class="line">estimator_expvals = job.result()[<span class="number">0</span>].data.evs</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Estimator results:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (obs, expval) <span class="keyword">in</span> <span class="built_in">zip</span>(observables, estimator_expvals):</span><br><span class="line">    <span class="keyword">if</span> obs <span class="keyword">is</span> <span class="keyword">not</span> H:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  &gt;&gt; Expected value of <span class="subst">&#123;<span class="built_in">str</span>(obs)&#125;</span>: <span class="subst">&#123;expval:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  &gt;&gt; Total expected value: <span class="subst">&#123;expval:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="数学严谨性（可选）"><a href="#数学严谨性（可选）" class="headerlink" title="数学严谨性（可选）"></a>数学严谨性（可选）</h3><p>表示∣ψ⟩ 相对于H^的特征态基，∣ψ⟩&#x3D;∑_λ a_λ ∣λ⟩，则：</p>
<p><img src="/./../../images/Qiskit/Day06/12.png"></p>
<p>由于我们不知道目标可观测量H^的特征值或特征态，因此首先我们需要考虑其对角化。假设H^<br>是厄米矩阵，则存在一个酉变换V 使得H^&#x3D;V†ΛV，其中Λ 是对角特征值矩阵，因此如果j≠k，则⟨j∣Λ∣k⟩&#x3D;0，且⟨j∣Λ∣j⟩&#x3D;λ。</p>
<p>这意味着预期值可以重写为：</p>
<p><img src="/./../../images/Qiskit/Day06/13.png"></p>
<p>假设系统处于状态∣ϕ⟩&#x3D;V∣ψ⟩ ，则测量∣j⟩ 的概率为pj&#x3D;∣⟨j∣ϕ⟩∣^2，则上述期望值可以表示为：</p>
<p><img src="/./../../images/Qiskit/Day06/14.png"></p>
<p>需要特别注意的是，概率取自状态V∣ψ⟩ 而不是∣ψ⟩。这就是为什么矩阵V 是绝对必要的。</p>
<p>您可能想知道如何获得矩阵V 和特征值Λ。如果您已经有了特征值，那么就不需要使用量子计算机了，因为变分算法的目标是找到H^的这些特征值。</p>
<p>幸运的是，有一种方法可以解决这个问题：任何2^n×2^n矩阵都可以写成4^n张量积的线性组合，这些张量积是n 个 Pauli 矩阵和恒等式的，它们都是厄米矩阵和幺正矩阵，并且已知V 和Λ。这就是 Runtime 的 Estimator 在内部所做的工作，它将任何Operator对象分解为SparsePauliOp 。</p>
<p>以下是可以使用的运算符：</p>
<p><img src="/./../../images/Qiskit/Day06/15.png"></p>
<p>因此，让我们根据 Paulis 和恒等式重写H^<br><img src="/./../../images/Qiskit/Day06/16.png"></p>
<p><img src="/./../../images/Qiskit/Day06/17.png"></p>
<h2 id="Cost-functions"><a href="#Cost-functions" class="headerlink" title="Cost functions"></a>Cost functions</h2><p>一般来说，成本函数用于描述问题的目标以及试验状态相对于该目标的表现。此定义可应用于化学、机器学习、金融、优化等领域的各种示例。</p>
<p>让我们考虑一个寻找系统基态的简单示例。我们的目标是最小化表示能量的可观测量的期望值（哈密顿量<br>H^）：</p>
<p><img src="/./../../images/Qiskit/Day06/18.png"></p>
<p>我们可以使用估算器来评估期望值，并将该值传递给优化器以最小化。如果优化成功，它将返回一组最佳参数值θ∗，从中我们将能够构建建议的解决方案状态∣ψ(θ∗)⟩ 并计算观察到的期望值为C(θ∗)。</p>
<p>请注意，我们将只能最小化我们正在考虑的有限状态集的成本函数。这导致我们得出两种不同的可能性：</p>
<p>我们的假设没有定义搜索空间中的解决方案状态：如果是这种情况，我们的优化器将永远找不到解决方案，我们需要尝试其他可能能够更准确地表示我们的搜索空间的假设。<br>我们的优化器无法找到这个有效的解决方案：优化可以全局定义，也可以局部定义。我们将在后面的部分探讨这意味着什么。<br>总而言之，我们将执行经典的优化循环，但依赖于量子计算机对成本函数的评估。从这个角度来看，我们可以将优化视为一种纯粹的经典努力，每次优化器需要评估成本函数时，我们都会调用一些黑盒量子预言机。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cost_func_vqe</span>(<span class="params">params, circuit, hamiltonian, estimator</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return estimate of energy from estimator</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters:</span></span><br><span class="line"><span class="string">        params (ndarray): Array of ansatz parameters</span></span><br><span class="line"><span class="string">        ansatz (QuantumCircuit): Parameterized ansatz circuit</span></span><br><span class="line"><span class="string">        hamiltonian (SparsePauliOp): Operator representation of Hamiltonian</span></span><br><span class="line"><span class="string">        estimator (Estimator): Estimator primitive instance</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        float: Energy estimate</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pub = (circuit, hamiltonian, params)</span><br><span class="line">    cost = estimator.run([pub]).result()[<span class="number">0</span>].data.evs</span><br><span class="line"></span><br><span class="line"><span class="comment">#    cost = estimator.run(ansatz, hamiltonian, parameter_values=params).result().values[0]</span></span><br><span class="line">    <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.circuit.library <span class="keyword">import</span> TwoLocal</span><br><span class="line"></span><br><span class="line">observable = SparsePauliOp.from_list([(<span class="string">&quot;XX&quot;</span>, <span class="number">1</span>), (<span class="string">&quot;YY&quot;</span>, -<span class="number">3</span>)])</span><br><span class="line"></span><br><span class="line">reference_circuit = QuantumCircuit(<span class="number">2</span>)</span><br><span class="line">reference_circuit.x(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">variational_form = TwoLocal(</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    rotation_blocks=[<span class="string">&quot;rz&quot;</span>, <span class="string">&quot;ry&quot;</span>],</span><br><span class="line">    entanglement_blocks=<span class="string">&quot;cx&quot;</span>,</span><br><span class="line">    entanglement=<span class="string">&quot;linear&quot;</span>,</span><br><span class="line">    reps=<span class="number">1</span>,</span><br><span class="line">)</span><br><span class="line">ansatz = reference_circuit.compose(variational_form)</span><br><span class="line"></span><br><span class="line">theta_list = (<span class="number">2</span> * np.pi * np.random.rand(<span class="number">1</span>, <span class="number">8</span>)).tolist()</span><br><span class="line"><span class="comment">#ansatz.assign_parameters(theta_list)</span></span><br><span class="line"><span class="comment">#print(ansatz.num_parameters)</span></span><br><span class="line">ansatz.decompose().draw(<span class="string">&#x27;mpl&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day06/f4.png"></p>
<p>我们将首先使用模拟器执行此操作：StatevectorEstimator。这通常适用于调试，但我们将在调试运行后立即在真实量子硬件上进行计算。越来越多的人不再能够在没有最先进的超级计算设施的情况下以经典方式模拟感兴趣的问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">estimator = StatevectorEstimator()</span><br><span class="line">cost = cost_func_vqe(theta_list, ansatz, observable, estimator)</span><br><span class="line"><span class="built_in">print</span>(cost)</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1.94770104]</span><br></pre></td></tr></table></figure>

<p>现在，我们将继续在真正的量子计算机上运行。请注意语法变化。涉及 pass_manager 的步骤将在下一个示例中进一步讨论。变分算法中特别重要的一个步骤是使用 Qiskit 运行时会话。启动会话允许您运行变分算法的多次迭代，而无需在每次更新参数时在新的队列中等待。如果排队时间很长和&#x2F;或需要多次迭代，这一点很重要。只有 IBM Quantum Network 中的合作伙伴才能使用运行时会话。如果您无权访问会话，则可以减少在给定时间提交的迭代次数，并保存最新的参数以供将来运行使用。如果您提交了太多迭代或遇到过长的排队时间，您可能会遇到错误代码 1217，这指的是作业提交之间的长时间延迟。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Estimated usage: &lt; 1 min. Benchmarked at 7 seconds on ibm_osaka, 5-23-24</span></span><br><span class="line"><span class="comment">#Load necessary packages:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> qiskit_ibm_runtime <span class="keyword">import</span> QiskitRuntimeService, Session, EstimatorV2 <span class="keyword">as</span> Estimator</span><br><span class="line"><span class="keyword">from</span> qiskit.transpiler.preset_passmanagers <span class="keyword">import</span> generate_preset_pass_manager</span><br><span class="line"></span><br><span class="line"><span class="comment">#Select the least busy backend:</span></span><br><span class="line"></span><br><span class="line">service = QiskitRuntimeService(channel=<span class="string">&quot;ibm_quantum&quot;</span>)</span><br><span class="line">backend = service.least_busy(</span><br><span class="line">    operational=<span class="literal">True</span>, min_num_qubits=ansatz.num_qubits, simulator=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Use a pass manager to transpile the circuit and observable for the specific backend being used:</span></span><br><span class="line"></span><br><span class="line">pm = generate_preset_pass_manager(backend=backend, optimization_level=<span class="number">1</span>)</span><br><span class="line">isa_ansatz = pm.run(ansatz)</span><br><span class="line">isa_observable = observable.apply_layout(layout = isa_ansatz.layout)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Open a Runtime session:</span></span><br><span class="line"></span><br><span class="line">session = Session(backend=backend)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use estimator to get the expected values corresponding to the ansatz</span></span><br><span class="line"></span><br><span class="line">estimator = Estimator(session=session)</span><br><span class="line">cost = cost_func_vqe(theta_list, isa_ansatz, isa_observable, estimator)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Close session after done</span></span><br><span class="line">session.close()</span><br><span class="line"><span class="built_in">print</span>(cost)</span><br></pre></td></tr></table></figure>

<p>请注意，上述两次计算所得的值非常相似。下文将进一步讨论改进结果的技术。</p>
<h2 id="测量策略：速度与准确度"><a href="#测量策略：速度与准确度" class="headerlink" title="测量策略：速度与准确度"></a>测量策略：速度与准确度</h2><p>如上所述，我们使用嘈杂的量子计算机作为黑盒预言机，其中噪声会使检索到的值不确定，从而导致随机波动，进而会损害（甚至完全阻止）某些优化器收敛到所提出的解决方案。这是我们在逐步探索量子效用并朝着量子优势迈进时必须解决的一个普遍问题：</p>
<p><img src="/./../../images/Qiskit/Day06/20.png"></p>
<p>我们可以使用 Qiskit Runtime Primitive 的错误抑制和错误缓解选项来解决噪声并最大限度地提高当今量子计算机的效用。</p>
<h2 id="错误抑制"><a href="#错误抑制" class="headerlink" title="错误抑制"></a>错误抑制</h2><p>错误抑制是指在编译过程中用于优化和转换电路以尽量减少错误的技术。这是一种基本的错误处理技术，通常会导致整个运行时产生一些经典的预处理开销。开销包括通过以下方式将电路转译为在量子硬件上运行：</p>
<p>使用量子系统上可用的本机门表达电路<br>将虚拟量子位映射到物理量子位<br>根据连接要求添加 SWAP<br>优化 1Q 和 2Q 门向空闲量子位添加动态解耦以防止退相干的影响。</p>
<p>通过设置optimization_level 选项并选择高级转译选项，原语允许使用错误抑制技术。在后面的课程中，我们将深入研究不同的电路构造方法来改进结果，但在大多数情况下，我们建议设置optimization_level&#x3D;3。</p>
<p>我们将通过查看具有简单理想行为的示例电路来直观地了解在转译过程中增加优化的价值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from qiskit.circuit import Parameter, QuantumCircuit</span><br><span class="line">from qiskit.quantum_info import SparsePauliOp</span><br><span class="line"></span><br><span class="line">theta = Parameter(&quot;theta&quot;)</span><br><span class="line"></span><br><span class="line">qc = QuantumCircuit(2)</span><br><span class="line">qc.x(1)</span><br><span class="line">qc.h(0)</span><br><span class="line">qc.cp(theta, 0, 1)</span><br><span class="line">qc.h(0)</span><br><span class="line">observables = SparsePauliOp.from_list([(&quot;ZZ&quot;, 1)])</span><br><span class="line"></span><br><span class="line">qc.draw(&quot;mpl&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day06/f5.png"></p>
<p>只要我们插入跨越适当间隔的相位，例如[0,2π]，上述电路就可以产生给定可观测量的正弦期望值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Setup phases</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">phases = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># phases need to be expressed as a list of lists in order to work</span></span><br><span class="line">individual_phases = [[phase] <span class="keyword">for</span> phase <span class="keyword">in</span> phases]</span><br></pre></td></tr></table></figure>

<p>我们可以使用模拟器来展示优化转译的实用性。下面我们将使用真实硬件来展示错误缓解的实用性。我们将使用 QiskitRuntimeService 获取真实后端（在本例中为 ibm_sherbrooke），并使用 AerSimulator 来模拟该后端，包括其噪声行为。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit_ibm_runtime <span class="keyword">import</span> QiskitRuntimeService</span><br><span class="line"><span class="keyword">from</span> qiskit_aer <span class="keyword">import</span> AerSimulator</span><br><span class="line"></span><br><span class="line"><span class="comment"># get a real backend from the runtime service</span></span><br><span class="line">service = QiskitRuntimeService()</span><br><span class="line">backend = service.get_backend(<span class="string">&#x27;ibm_sherbrooke&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># generate a simulator that mimics the real quantum system with the latest calibration results</span></span><br><span class="line">backend_sim = AerSimulator.from_backend(backend)</span><br></pre></td></tr></table></figure>

<p>我们现在可以使用 pass manager 将电路转换为后端的“指令集架构”或 ISA。这是 Qiskit Runtime 中的一项新要求：提交给后端的所有电路都必须符合后端目标的约束，这意味着它们必须按照后端的 ISA 编写 - 即设备可以理解和执行的指令集。这些目标约束由设备本机基础门、量子比特连接以及（如果相关）脉冲和其他指令时序规范等因素定义。</p>
<p>请注意，在本例中，我们将执行两次：一次将optimization_level &#x3D; 0，一次将其设置为 3。每次我们都将使用 Estimator 原语来估计不同相位值下可观测量的期望值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Import estimator and specify that we are using the simulated backend:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> qiskit_ibm_runtime <span class="keyword">import</span> EstimatorV2 <span class="keyword">as</span> Estimator</span><br><span class="line">estimator = Estimator(backend = backend_sim)</span><br><span class="line"></span><br><span class="line">circuit = qc</span><br><span class="line"></span><br><span class="line"><span class="comment">#Use a pass manager to transpile the circuit and observable for the backend being simulated.</span></span><br><span class="line"><span class="comment">#Start with no optimization:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> qiskit.transpiler.preset_passmanagers <span class="keyword">import</span> generate_preset_pass_manager</span><br><span class="line"></span><br><span class="line">pm = generate_preset_pass_manager(backend=backend_sim, optimization_level=<span class="number">0</span>)</span><br><span class="line">isa_circuit = pm.run(circuit)</span><br><span class="line">isa_observables = observables.apply_layout(layout = isa_circuit.layout)</span><br><span class="line"></span><br><span class="line">noisy_exp_values = []</span><br><span class="line">pub = (isa_circuit, isa_observables, [individual_phases])</span><br><span class="line">cost = estimator.run([pub]).result()[<span class="number">0</span>].data.evs</span><br><span class="line">noisy_exp_values = cost[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Repeat above steps, but now with optimization = 3:</span></span><br><span class="line"></span><br><span class="line">exp_values_with_opt_es = []</span><br><span class="line">pm = generate_preset_pass_manager(backend=backend_sim, optimization_level=<span class="number">3</span>)</span><br><span class="line">isa_circuit = pm.run(circuit)</span><br><span class="line">isa_observables = observables.apply_layout(layout = isa_circuit.layout)</span><br><span class="line"></span><br><span class="line">pub = (isa_circuit, isa_observables, [individual_phases])</span><br><span class="line">cost = estimator.run([pub]).result()[<span class="number">0</span>].data.evs</span><br><span class="line">exp_values_with_opt_es = cost[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>最后，我们可以绘制结果，我们发现即使没有优化，计算的精度也相当不错，但通过将优化级别提高到 3，计算的精度肯定会提高。请注意，在更深、更复杂的电路中，优化级别 0 和 3 之间的差异可能更大。这是一个用作玩具模型的非常简单的电路。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.plot(phases, noisy_exp_values, &quot;o&quot;, label=&quot;opt=0&quot;)</span><br><span class="line">plt.plot(phases, exp_values_with_opt_es, &quot;o&quot;, label=&quot;opt=3&quot;)</span><br><span class="line">plt.plot(phases, 2 * np.sin(phases / 2) ** 2 - 1, label=&quot;ideal&quot;)</span><br><span class="line">plt.ylabel(&quot;Expectation&quot;)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="/./../../images/Qiskit/Day06/f6.png"></p>
<h2 id="错误缓解"><a href="#错误缓解" class="headerlink" title="错误缓解"></a>错误缓解</h2><p>错误缓解是指允许用户通过在执行时对设备噪声进行建模来减少电路错误的技术。通常，这会导致与模型训练相关的量子预处理开销和使用生成的模型缓解原始结果中错误的经典后处理开销。</p>
<p>Qiskit Runtime 原语的 resilience_level 选项指定针对错误构建的弹性量。更高的级别会产生更准确的结果，但由于量子采样开销，处理时间会更长。在将错误缓解应用于原始查询时，可以使用弹性级别来配置成本和准确性之间的权衡。</p>
<p>在实施任何错误缓解技术时，我们希望结果中的偏差相对于之前未缓解的偏差有所减少。在某些情况下，偏差甚至可能消失。然而，这是有代价的。随着我们减少估计量的偏差，统计变异性将增加（即方差），我们可以通过进一步增加采样过程中每个电路的采样次数来解决这个问题。这将引入超出减少偏差所需的开销，因此默认情况下不执行此操作。我们可以通过在 options.executions.shots 中调整每个电路的镜头数量来轻松选择此行为，如下例所示。</p>
<p><img src="/./../../images/Qiskit/Day06/f7.png"></p>
<p>在本课程中，我们将从高层次探讨这些错误缓解模型，以说明 Qiskit Runtime 原语无需完整的实现细节即可执行的错误缓解。</p>
<h3 id="旋转读出误差消光-T-REx"><a href="#旋转读出误差消光-T-REx" class="headerlink" title="旋转读出误差消光 (T-REx)"></a>旋转读出误差消光 (T-REx)</h3><p>旋转读出误差消除 (T-REx) 使用一种称为 Pauli 旋转的技术来减少量子测量过程中引入的噪声。该技术不假设任何特定形式的噪声，因此非常通用且有效。</p>
<p>总体工作流程：</p>
<p>使用随机位翻转获取零状态的数据（测量前的 Pauli X）<br>使用随机位翻转获取所需（噪声）状态的数据（测量前的 Pauli X）<br>计算每个数据集的特殊函数，然后除法。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">陈智涛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/12/24/Qiskit%E8%AF%BE%E7%A8%8B/%E5%8F%98%E5%88%86%E7%AE%97%E6%B3%95/">http://example.com/2024/12/24/Qiskit%E8%AF%BE%E7%A8%8B/%E5%8F%98%E5%88%86%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">ZTCodeGarden</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/01.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/24/Java%E5%AD%A6%E4%B9%A0/Java%E5%85%A5%E9%97%A8/Java%E5%85%A5%E9%97%A8%E4%B8%AD%E4%B8%8A/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2024/12/23/Java%E8%93%9D%E6%A1%A5%E6%9D%AF/%E5%80%8D%E5%A2%9E/" title="倍增"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">倍增</div></div><div class="info-2"><div class="info-item-1">倍增 快速幂例题1 思路 代码123456789101112131415161718192021222324252627package day03;//快速幂public class test01 &#123;   public static void main(String[] args) &#123;          Scanner sc = new Scanner(System.in);          int a = sc.nextInt();          int b = sc.nextInt();          int p = sc.nextInt();          sc.close();          long res = fastPower(a, b, p);          System.out.println(a + &quot;^&quot; + b + &quot; mod &quot;+ p+ &quot;=&quot; + res);    &#125;    public static long qmi(long a,...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/01.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">陈智涛</div><div class="author-info-description">纵使前路茫茫，莫回头，随心荡人间</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E5%88%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">变分算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E5%88%86%E5%AE%9A%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">变分定理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E9%87%8F%E5%92%8C%E5%9F%BA%E6%80%81%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9B%B4%E8%A7%89"><span class="toc-number">1.2.</span> <span class="toc-text">能量和基态的数学直觉</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8F%E5%AD%90%E5%8A%9B%E5%AD%A6%E7%9A%84%E5%8F%98%E5%88%86%E5%AE%9A%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">量子力学的变分定理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%8A%B6%E6%80%81"><span class="toc-number">2.</span> <span class="toc-text">参考状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">默认状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%8F%82%E8%80%83%E6%80%81"><span class="toc-number">2.2.</span> <span class="toc-text">经典参考态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8F%E5%AD%90%E5%8F%82%E8%80%83%E6%80%81"><span class="toc-number">2.3.</span> <span class="toc-text">量子参考态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%94%B5%E8%B7%AF%E6%9E%84%E5%BB%BA%E5%8F%82%E8%80%83%E7%8A%B6%E6%80%81"><span class="toc-number">2.4.</span> <span class="toc-text">使用模板电路构建参考状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E4%BA%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8F%82%E8%80%83%E7%8A%B6%E6%80%81"><span class="toc-number">2.5.</span> <span class="toc-text">特定于应用程序的参考状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8F%E5%AD%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.5.1.</span> <span class="toc-text">量子机器学习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%9F%E5%AE%9A%E5%BD%A2%E5%BC%8F%E5%92%8C%E5%8F%98%E5%88%86%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">拟定形式和变分形式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96%E9%87%8F%E5%AD%90%E7%94%B5%E8%B7%AF"><span class="toc-number">3.1.</span> <span class="toc-text">参数化量子电路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E5%88%86%E5%BD%A2%E5%BC%8F%E5%92%8C%E5%81%87%E8%AE%BE"><span class="toc-number">3.2.</span> <span class="toc-text">变分形式和假设</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E5%88%86%E6%9E%90%E5%92%8C%E6%9D%83%E8%A1%A1"><span class="toc-number">3.2.1.</span> <span class="toc-text">启发式分析和权衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#N-%E5%B1%80%E9%83%A8%E7%94%B5%E8%B7%AF"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">N 局部电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%95%88SU2"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">高效SU2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E7%89%B9%E5%AE%9A%E7%9A%84%E5%81%87%E8%AE%BE"><span class="toc-number">3.2.2.</span> <span class="toc-text">问题特定的假设</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8F%E5%AD%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-1"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">量子机器学习</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cost-Functions"><span class="toc-number">4.</span> <span class="toc-text">Cost Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD"><span class="toc-number">4.1.</span> <span class="toc-text">原语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E5%99%A8%E5%8E%9F%E8%AF%AD"><span class="toc-number">4.1.1.</span> <span class="toc-text">采样器原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B0%E7%AE%97%E5%99%A8%E5%8E%9F%E8%AF%AD"><span class="toc-number">4.1.2.</span> <span class="toc-text">估算器原语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%9B%E5%80%BC%E7%9A%84%E6%8C%87%E5%AF%BC%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">计算期望值的指导示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%AE%9E%E9%AA%8C"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">一个完整的实验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E4%B8%A5%E8%B0%A8%E6%80%A7%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-number">4.1.4.</span> <span class="toc-text">数学严谨性（可选）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cost-functions"><span class="toc-number">4.2.</span> <span class="toc-text">Cost functions</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E9%87%8F%E7%AD%96%E7%95%A5%EF%BC%9A%E9%80%9F%E5%BA%A6%E4%B8%8E%E5%87%86%E7%A1%AE%E5%BA%A6"><span class="toc-number">4.3.</span> <span class="toc-text">测量策略：速度与准确度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%8A%91%E5%88%B6"><span class="toc-number">4.4.</span> <span class="toc-text">错误抑制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%BC%93%E8%A7%A3"><span class="toc-number">4.5.</span> <span class="toc-text">错误缓解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E8%AF%BB%E5%87%BA%E8%AF%AF%E5%B7%AE%E6%B6%88%E5%85%89-T-REx"><span class="toc-number">4.5.1.</span> <span class="toc-text">旋转读出误差消光 (T-REx)</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" href="/2024/12/30/Java%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/Day01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%882%EF%BC%89/" title="反转字符串（2）">反转字符串（2）</a><time datetime="2024-12-30T13:36:45.000Z" title="发表于 2024-12-30 21:36:45">2024-12-30</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/12/26/Java%E8%93%9D%E6%A1%A5%E6%9D%AF/dfs%E5%9B%9E%E6%BA%AF/" title="dfs回溯">dfs回溯</a><time datetime="2024-12-26T14:19:29.000Z" title="发表于 2024-12-26 22:19:29">2024-12-26</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/12/25/Java%E8%93%9D%E6%A1%A5%E6%9D%AF/DFS/" title="DFS">DFS</a><time datetime="2024-12-25T14:07:37.000Z" title="发表于 2024-12-25 22:07:37">2024-12-25</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/12/25/Qiskit%E8%AF%BE%E7%A8%8B/SingleSystem/VQE%E6%A1%86%E6%9E%B6/" title="无标题">无标题</a><time datetime="2024-12-25T08:40:20.752Z" title="发表于 2024-12-25 16:40:20">2024-12-25</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/12/25/Qiskit%E8%AF%BE%E7%A8%8B/SingleSystem/%E5%8F%98%E5%88%86%E7%BA%BF%E8%B7%AF%E7%90%86%E8%A7%A3/" title="无标题">无标题</a><time datetime="2024-12-25T07:32:25.248Z" title="发表于 2024-12-25 15:32:25">2024-12-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By 陈智涛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>