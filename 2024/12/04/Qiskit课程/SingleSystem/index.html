<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>QiskitExamples | ZTCodeGarden</title><meta name="author" content="陈智涛"><meta name="copyright" content="陈智涛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第一课在本节中，我们将介绍本课中介绍的概念的一些 Qiskit 实现的示例。 Python 中的向量和矩阵Qiskit 使用 Python 编程语言，因此在具体讨论 Qiskit 之前，简要讨论一下 Python 中的矩阵和向量计算可能会有所帮助。在 Python 中，可以使用“NumPy”库中的“array”类（其中包含许多用于数值计算的附加组件）执行矩阵和向量计算。 下面是一个代码单元的示例，">
<meta property="og:type" content="article">
<meta property="og:title" content="QiskitExamples">
<meta property="og:url" content="http://example.com/2024/12/04/Qiskit%E8%AF%BE%E7%A8%8B/SingleSystem/index.html">
<meta property="og:site_name" content="ZTCodeGarden">
<meta property="og:description" content="第一课在本节中，我们将介绍本课中介绍的概念的一些 Qiskit 实现的示例。 Python 中的向量和矩阵Qiskit 使用 Python 编程语言，因此在具体讨论 Qiskit 之前，简要讨论一下 Python 中的矩阵和向量计算可能会有所帮助。在 Python 中，可以使用“NumPy”库中的“array”类（其中包含许多用于数值计算的附加组件）执行矩阵和向量计算。 下面是一个代码单元的示例，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/01.jpg">
<meta property="article:published_time" content="2024-12-04T07:15:51.000Z">
<meta property="article:modified_time" content="2024-12-21T03:50:32.812Z">
<meta property="article:author" content="陈智涛">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/01.jpg"><link rel="shortcut icon" href="/img/02.jpg"><link rel="canonical" href="http://example.com/2024/12/04/Qiskit%E8%AF%BE%E7%A8%8B/SingleSystem/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'QiskitExamples',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/02.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/01.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">ZTCodeGarden</span></a><a class="nav-page-title" href="/"><span class="site-name">QiskitExamples</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">QiskitExamples</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-04T07:15:51.000Z" title="发表于 2024-12-04 15:15:51">2024-12-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-21T03:50:32.812Z" title="更新于 2024-12-21 11:50:32">2024-12-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="第一课"><a href="#第一课" class="headerlink" title="第一课"></a>第一课</h2><p>在本节中，我们将介绍本课中介绍的概念的一些 Qiskit 实现的示例。</p>
<h3 id="Python-中的向量和矩阵"><a href="#Python-中的向量和矩阵" class="headerlink" title="Python 中的向量和矩阵"></a>Python 中的向量和矩阵</h3><p>Qiskit 使用 Python 编程语言，因此在具体讨论 Qiskit 之前，简要讨论一下 Python 中的矩阵和向量计算可能会有所帮助。在 Python 中，可以使用“NumPy”库中的“array”类（其中包含许多用于数值计算的附加组件）执行矩阵和向量计算。</p>
<p>下面是一个代码单元的示例，它定义了两个向量 ket0 和 ket1 ，分别对应于量子位状态向量∣0⟩ 和∣1⟩,<br>并显示它们的平均值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line">ket0 = array([<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">ket1 = array([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ket0 / <span class="number">2</span> + ket1 / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([0.5, 0.5])</span><br></pre></td></tr></table></figure>

<p>我们还可以使用“数组”来创建表示操作的矩阵。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M1 = array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">M2 = array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(M1 / <span class="number">2</span> + M2 / <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[1. , 1. ],</span><br><span class="line">       [0.5, 0. ]])</span><br></pre></td></tr></table></figure>

<p>矩阵乘法（包括矩阵向量乘法作为特殊情况）可以使用 <code>NumPy</code> 中的 <code>matmul</code> 函数执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> matmul</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> array</span><br><span class="line"></span><br><span class="line">ket0 = array([<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">ket1 = array([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">M1 = array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">M2 = array([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(matmul(M1, ket1))</span><br><span class="line"><span class="built_in">print</span>(matmul(M1, M2))</span><br><span class="line"><span class="built_in">print</span>(matmul(M2, M1))</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([1, 0])</span><br><span class="line">array([[2, 1],</span><br><span class="line">       [0, 0]])</span><br><span class="line">array([[1, 1],</span><br><span class="line">       [1, 1]])</span><br></pre></td></tr></table></figure>

<h3 id="状态、测量和操作"><a href="#状态、测量和操作" class="headerlink" title="状态、测量和操作"></a>状态、测量和操作</h3><p>Qiskit 包含多个类，允许轻松创建和操作状态、测量和操作 — 因此无需从头开始并用 Python 编写模拟量子状态、测量和操作所需的一切。下面包含一些入门示例。</p>
<h4 id="1-定义和显示状态向量"><a href="#1-定义和显示状态向量" class="headerlink" title="1.定义和显示状态向量"></a>1.定义和显示状态向量</h4><p><strong>(1)<strong>Qiskit 的“Statevector”类提供了</strong>定义和操作量子态向量的功能</strong>。以下代码单元导入“Statevector”类并使用它定义一些向量。（请注意，我们需要“NumPy”库中的“sqrt”函数来计算向量“u”的平方根。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span> Statevector</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line">u = Statevector([<span class="number">1</span> / sqrt(<span class="number">2</span>), <span class="number">1</span> / sqrt(<span class="number">2</span>)])</span><br><span class="line">v = Statevector([(<span class="number">1</span> + <span class="number">2.0j</span>) / <span class="number">3</span>, -<span class="number">2</span> / <span class="number">3</span>])</span><br><span class="line">w = Statevector([<span class="number">1</span> / <span class="number">3</span>, <span class="number">2</span> / <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(u)</span><br><span class="line"><span class="built_in">print</span>(v)</span><br><span class="line"><span class="built_in">print</span>(w)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;State vectors u, v, and w have been defined.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Statevector([0.70710678+0.j, 0.70710678+0.j],</span><br><span class="line">            dims=(2,))</span><br><span class="line">Statevector([ 0.33333333+0.66666667j, -0.66666667+0.j        ],</span><br><span class="line">            dims=(2,))</span><br><span class="line">Statevector([0.33333333+0.j, 0.66666667+0.j],</span><br><span class="line">            dims=(2,))</span><br><span class="line">State vectors u, v, and w have been defined.</span><br></pre></td></tr></table></figure>

<p><strong>(2)</strong><code>Statevector</code> 类提供了一种用于显示状态向量的 <code>draw</code> 方法，包括用于不同可视化的 <code>latex</code> 和 <code>text</code> 选项，如以下代码单元所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span> Statevector</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display, Latex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建量子态向量</span></span><br><span class="line">u = Statevector([<span class="number">1</span> / sqrt(<span class="number">2</span>), <span class="number">1</span> / sqrt(<span class="number">2</span>)])</span><br><span class="line">v = Statevector([(<span class="number">1</span> + <span class="number">2.0j</span>) / <span class="number">3</span>, -<span class="number">2</span> / <span class="number">3</span>])</span><br><span class="line">w = Statevector([<span class="number">1</span> / <span class="number">3</span>, <span class="number">2</span> / <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用 display 来渲染 LaTeX 格式的量子态 pycharm中无法显示</span></span><br><span class="line">display(u.draw(<span class="string">&quot;latex&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印文本格式的量子态向量</span></span><br><span class="line"><span class="built_in">print</span>(v.draw(<span class="string">&quot;text&quot;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Output:</p>
<p>pycharm中无法显示<br>$$<br>\frac{\sqrt{2}}{2}\vert0\rangle + \frac{\sqrt{2}}{2}\vert1\rangle<br>$$<br>pycharm中可以显示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 0.33333333+0.66666667j,-0.66666667+0.j        ]</span><br></pre></td></tr></table></figure>

<p><strong>(3)</strong><code>Statevector</code> 类还包括 <code>is_valid</code> 方法，该方法检查给定向量是否是有效的量子态向量（即，它具有等于 1 的欧几里得范数）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span> Statevector</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display, Latex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建量子态向量</span></span><br><span class="line">u = Statevector([<span class="number">1</span> / sqrt(<span class="number">2</span>), <span class="number">1</span> / sqrt(<span class="number">2</span>)])</span><br><span class="line">v = Statevector([(<span class="number">1</span> + <span class="number">2.0j</span>) / <span class="number">3</span>, -<span class="number">2</span> / <span class="number">3</span>])</span><br><span class="line">w = Statevector([<span class="number">1</span> / <span class="number">3</span>, <span class="number">2</span> / <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">display(u.is_valid())  <span class="comment"># 有效态</span></span><br><span class="line">display(w.is_valid())  <span class="comment"># 非有效态</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h4 id="2-使用“Statevector”模拟测量"><a href="#2-使用“Statevector”模拟测量" class="headerlink" title="2.使用“Statevector”模拟测量"></a>2.使用“Statevector”模拟测量</h4><p>接下来，我们将看到一种在 Qiskit 中模拟量子态测量的方法，即使用“Statevector”类中的“measure”方法。</p>
<p>首先，我们创建一个量子位状态向量“v”，然后显示它。</p>
<p>接下来，运行“测量”方法模拟标准基础测量。它返回该测量的结果，以及该测量后我们系统的新量子态。</p>
<p>测量结果是概率性的，因此相同的方法可以返回不同的结果。尝试运行该单元几次以查看这一点。</p>
<p>对于上面定义的向量“v”的特定示例，“测量”方法将测量后的量子态向量定义为<br>$$<br>\frac{1 + 2i}{5}\vert0\rangle<br>$$</p>
<p>（而不是 ∣0⟩∣0⟩）或</p>
<p>​                                                                            −∣1⟩</p>
<p>（而不是 ∣1⟩∣1⟩），具体取决于测量结果。在这两种情况下，替代方案实际上是等效的——它们被称为<em>因全局相位而不同</em>，因为一个等于另一个乘以单位圆上的复数。这个问题在第 3 课中进行了更详细的讨论，现在可以安全地忽略它。</p>
<p>顺便说一句，如果将“measure”方法应用于无效的量子态向量，则“Statevector”将引发错误。如果您有兴趣看看错误是什么样子，请随意尝试一下。</p>
<p><code>Statevector</code> also comes with a <code>sample_counts</code> method that allows for the simulation of any number of measurements on the system. For example, the following cell shows the outcome of measuring the vector <code>v</code> 10001000 times, which (with high probability) results in the outcome 00 approximately 55 out of every 99 times (or about 556556 of the 10001000 trials) and the the outcome 11 approximately 44 out of every 99 times (or about 444444 out of the 10001000 trials). </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span> Statevector</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> display, Latex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建量子态向量</span></span><br><span class="line">v = Statevector([(<span class="number">1</span> + <span class="number">2.0j</span>) / <span class="number">3</span>, -<span class="number">2</span> / <span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(v.measure())</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Output:</p>
<p>结果1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line"> Statevector([ <span class="number">0.</span>+<span class="number">0.j</span>, -<span class="number">1.</span>+<span class="number">0.j</span>],</span><br><span class="line">             dims=(<span class="number">2</span>,)))</span><br></pre></td></tr></table></figure>

<p>结果2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&#x27;0&#x27;</span>, Statevector([<span class="number">0.4472136</span>+<span class="number">0.89442719j</span>, <span class="number">0.</span>       +<span class="number">0.j</span>        ],</span><br><span class="line">            dims=(<span class="number">2</span>,)))</span><br></pre></td></tr></table></figure>

<p>该单元格还演示了用于可视化结果的“plot_histogram”函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v = Statevector([(<span class="number">1</span> + <span class="number">2.0j</span>) / <span class="number">3</span>, -<span class="number">2</span> / <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行采样并生成统计数据</span></span><br><span class="line">statistics = v.sample_counts(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示采样统计</span></span><br><span class="line">display(statistics)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制直方图</span></span><br><span class="line">plot_histogram(statistics)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Output:</p>
<p>每次统计结果不一定一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;0&#x27;: 545, &#x27;1&#x27;: 455&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/png;base64,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AAYi5AEAABiIkAcAAGAgQh4AAICBCHkAAAAGIuQBAAAYiJAHAABgIEIeAACAgQh5AAAABiLkAQAAGIiQBwAAYCBCHgAAgIHsNd0AymfMopruAPiP5RNrugMAwNWwkgcAAGAgQh4AAICBCHkAAAAGIuQBAAAYiJAHAABgIEIeAACAgQh5AAAABiLkAQAAGIiQBwAAYCBCHgAAgIEIeQAAAAYi5AEAABiIkAcAAGAgQh4AAICBCHkAAAAGIuQBAAAYiJAHAABgIEIeAACAgQh5AAAABiLkAQAAGIiQBwAAYCBCHgAAgIEIeQAAAAYi5AEAABiIkAcAAGAgQh4AAICBCHkAAAAGIuQBAAAYiJAHAABgIEIeAACAgQh5AAAABiLkAQAAGIiQBwAAYCBCHgAAgIEIeQAAAAYi5AEAABiIkAcAAGAgQh4AAICBCHkAAAAGIuQBAAAYiJAHAABgIEIeAAA3iHnz5slisWjixIkltrlcLt19992yWCz65JNPSmxftWqVOnTooLp166pRo0YaN25c9TeMa2Kv6QYAAED1++qrr7R06VJ16NCh1O2LFi2SxWIpddurr76qhQsXasGCBeratasKCgp07NixauwWVYGQBwCA4fLz8/XQQw9p+fLleumll0psT01N1cKFC/X111+radOmHtvOnz+vF198UX//+9/Vr18/d72ssAjvwce1AAAYbty4cYqLi1P//v1LbPvpp580fPhwvfnmm2rSpEmJ7Zs3b5bT6dSpU6fUtm1bhYWFaejQocrIyLgereMaEPIAADDYmjVrtGfPHs2dO7fU7ZMmTVL37t117733lrr96NGjcjqdmjNnjhYtWqQPP/xQ586d04ABA3Tp0qXqbB3XiI9rAQAwVEZGhp5++mlt3rxZdevWLbH9008/1datW7V3794y9+F0OuVwOPT6668rNjZWkvT++++rSZMmSkxM1MCBA6utf1wbVvIAADDU7t279cMPP6hz586y2+2y2+3atm2bXn/9ddntdm3evFlHjhxRcHCwe7sk3XffferTp48kuc/Ru+WWW9z7bdiwoUJDQ3XixInrPieUHyt5AAAYql+/fjpw4IBH7dFHH1V0dLQmT56s0NBQ/elPf/LY3r59e7322mu65557JEk9evSQJB06dEhhYWGSpHPnzikrK0uRkZHXYRaoLEIeAACGCggIULt2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" alt="img"></p>
<p>多次运行该单元并尝试使用不同数量的样本来代替 10001000 可能有助于形成一些关于试验次数如何影响估计概率的直觉。</p>
<h4 id="3-使用-Operator-和-Statevector-执行操作"><a href="#3-使用-Operator-和-Statevector-执行操作" class="headerlink" title="3.使用 Operator 和 Statevector 执行操作&#96;"></a>3.使用 <code>Operator</code> 和 <code>Statevector</code> 执行操作&#96;</h4><p>可以使用“Operator”类在 Qiskit 中的状态向量上定义和执行酉运算，如下例所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span> Operator</span><br><span class="line"></span><br><span class="line">X = Operator([[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line">Y = Operator([[<span class="number">0</span>, -<span class="number">1.0j</span>], [<span class="number">1.0j</span>, <span class="number">0</span>]])</span><br><span class="line">Z = Operator([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]])</span><br><span class="line">H = Operator([[<span class="number">1</span> / sqrt(<span class="number">2</span>), <span class="number">1</span> / sqrt(<span class="number">2</span>)], [<span class="number">1</span> / sqrt(<span class="number">2</span>), -<span class="number">1</span> / sqrt(<span class="number">2</span>)]])</span><br><span class="line">S = Operator([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1.0j</span>]])</span><br><span class="line">T = Operator([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, (<span class="number">1</span> + <span class="number">1.0j</span>) / sqrt(<span class="number">2</span>)]])</span><br><span class="line"></span><br><span class="line">v = Statevector([<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">v = v.evolve(H)</span><br><span class="line">v = v.evolve(T)</span><br><span class="line">v = v.evolve(H)</span><br><span class="line">v = v.evolve(T)</span><br><span class="line">v = v.evolve(Z)</span><br><span class="line"></span><br><span class="line">v.draw(<span class="string">&quot;text&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 0.85355339+0.35355339j,-0.35355339+0.14644661j]</span><br></pre></td></tr></table></figure>

<h4 id="4-展望量子电路"><a href="#4-展望量子电路" class="headerlink" title="4.展望量子电路"></a>4.展望量子电路</h4><p>量子电路直到第 3 课才会正式介绍，但我们仍然可以尝试使用 Qiskit 的 QuantumCircuit 类来组合量子比特幺正运算。具体来说，我们可以定义一个量子电路（在本例中，它将只是对单个量子比特执行的一系列幺正运算），如下所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> QuantumCircuit</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建量子电路</span></span><br><span class="line">circuit = QuantumCircuit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用量子门</span></span><br><span class="line">circuit.h(<span class="number">0</span>)  <span class="comment"># Hadamard 门</span></span><br><span class="line">circuit.t(<span class="number">0</span>)  <span class="comment"># T 门</span></span><br><span class="line">circuit.h(<span class="number">0</span>)  <span class="comment"># 再次应用 Hadamard 门</span></span><br><span class="line">circuit.t(<span class="number">0</span>)  <span class="comment"># 再次应用 T 门</span></span><br><span class="line">circuit.z(<span class="number">0</span>)  <span class="comment"># Z 门</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印量子电路的线路图 (Matplotlib 图形)</span></span><br><span class="line">circuit.draw(output=<span class="string">&#x27;mpl&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>Output:</p>
<p><img src="data:image/png;base64,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" alt="img"></p>
<p>这些操作按顺序应用，从图中左侧开始，到右侧结束。让我们首先初始化一个起始量子态向量，然后根据操作顺序演化该状态。最后，让我们模拟运行这个实验（即准备状态∣0⟩，∣0⟩，应用电路所表示的操作序列，并进行测量）4000次的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> QuantumCircuit</span><br><span class="line"><span class="keyword">from</span> qiskit.quantum_info <span class="keyword">import</span> Statevector</span><br><span class="line"><span class="keyword">from</span> qiskit.visualization <span class="keyword">import</span> plot_histogram</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建量子电路</span></span><br><span class="line">circuit = QuantumCircuit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用量子门</span></span><br><span class="line">circuit.h(<span class="number">0</span>)  <span class="comment"># Hadamard 门</span></span><br><span class="line">circuit.t(<span class="number">0</span>)  <span class="comment"># T 门</span></span><br><span class="line">circuit.h(<span class="number">0</span>)  <span class="comment"># 再次应用 Hadamard 门</span></span><br><span class="line">circuit.t(<span class="number">0</span>)  <span class="comment"># 再次应用 T 门</span></span><br><span class="line">circuit.z(<span class="number">0</span>)  <span class="comment"># Z 门</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始量子态 |0&gt;，使用 Statevector 创建</span></span><br><span class="line">ket0 = Statevector([<span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 演化量子态</span></span><br><span class="line">v = ket0.evolve(circuit)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出量子态（文本形式）</span></span><br><span class="line"><span class="built_in">print</span>(v.draw(<span class="string">&quot;text&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取量子态的测量结果并进行采样</span></span><br><span class="line">statistics = v.sample_counts(<span class="number">4000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制采样的统计分布</span></span><br><span class="line">plot_histogram(statistics)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 0.85355339+0.35355339j,-0.35355339+0.14644661j]</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<p><img src="/./../../images/Qiskit/06.png"></p>
<h2 id="第二课"><a href="#第二课" class="headerlink" title="第二课"></a>第二课</h2><p>本课的重点是考虑多个系统时量子信息的基础知识。这种情况自然会出现在信息处理（经典和量子）的背景下。大型信息承载系统通常最容易使用较小系统的集合（例如位或量子位）构建。</p>
<p>在本课中要记住的一个简单但至关重要的想法是，我们始终可以选择将多个系统一起视为一个单一的复合系统——上一课中的讨论适用于此。事实上，这个想法非常直接地引出了对量子态、测量和操作如何适用于多个系统的描述。</p>
<p>然而，理解多个量子系统不仅仅是简单地认识到它们可以被视为单个系统。例如，我们可能有多个量子系统，它们集体处于特定的量子态，然后选择只测量单个系统中的一个（或适当的子集）。一般来说，这会影响其余系统的状态，在分析量子算法和协议时，准确理解如何影响状态非常重要。了解多个系统之间的各种关联（特别是一种称为纠缠的关联）对于量子信息和计算也很重要。</p>
<h3 id="经典信息"><a href="#经典信息" class="headerlink" title="经典信息"></a>经典信息</h3><p>与上一课一样，我们将从经典信息的讨论开始。再次强调，概率和量子描述在数学上是相似的，认识到数学在熟悉的经典信息环境中是如何运作的，有助于理解为什么量子信息以这种方式描述</p>
<h4 id="1-通过笛卡尔积的经典状态"><a href="#1-通过笛卡尔积的经典状态" class="headerlink" title="1.通过笛卡尔积的经典状态"></a>1.通过笛卡尔积的经典状态</h4><p>我们将从最基础的层面开始，即多系统的经典状态。为简单起见，我们将从讨论两个系统开始，然后再推广到两个以上的系统</p>
<p>准确地说，<strong>我们假设X 是一个系统，其经典状态集为Σ，而Y是第二个系统，其经典状态集为Γ</strong>.与上一课一样，因为我们将这些集合称为经典状态集，<strong>所以我们假设Σ 和ΓΓ 都是有限的和非空的。可能是Σ&#x3D;Γ,但不一定如此——无论如何，为了清楚起见，使用不同的名称来指代这些集合是有帮助的。</strong></p>
<p>现在想象一下两个系统X 和Y 并排放置，X 在左边，Y 在右边。如果我们愿意，我们可以将这两个系统视为一个系统，我们可以根据自己的喜好将其表示为(X,Y)或XY。</p>
<p>关于这个<strong>复合系统(X,Y)</strong> 的一个自然问题是，“它的经典状态是什么？”</p>
<p><strong>答案是(X,Y) 的经典状态集是Σ 和Γ 的笛卡尔积，其定义为</strong><br>$$<br>\Sigma \times \Gamma &#x3D; {(a, b): a \in \Sigma \text{ and } b \in \Gamma}<br>$$<br>简而言之，笛卡尔积恰恰是一种数学概念，它体现了将一个集合的元素和第二个集合的元素放在一起看作是单个集合的单个元素的想法。</p>
<p>在本例中，说(X,Y) 处于经典状态(a,b)∈Σ×Γ 意味着X 处于经典状态a∈Σ 且Y 处于经典状态b∈Γ；如果</p>
<p>X 的经典状态为a∈Σ 且Y 的经典状态为b∈Γ，则联合系统(X,Y) 的经典状态为(a,b)。</p>
<p>对于两个以上的系统，这种情况可以自然推广。<strong>如果我们假设X1,…,Xn分别是具有经典状态集Σ1,…,Σn</strong></p>
<p><strong>的系统，对于任何正整数n，则n 元组的经典状态集(X1,…,Xn) 被视为单关节系统，是笛卡尔积</strong><br>$$<br>\Sigma_1 \times \cdots \times \Sigma_n &#x3D; {(a_1, \dots, a_n): a_1 \in \Sigma_1, \dots, a_n \in \Sigma_n }<br>$$</p>
<p>请注意，我们可以自由地使用任何我们想要的系统名称，并且可以自由地按我们的选择对它们进行排序。特别是，如果我们有n 个系统（如上所示），我们可以选择将它们命名为Xn−1,…,X0并按以下方式对它们进行排序，即(Xn−1,…,X0)。模仿命名相关经典状态和经典状态集的相同模式，我们可能会引用该复合系统的经典状态(an−1,…,a0)∈Σn−1×⋯×Σ0。事实上，这是 Qiskit 用于命名量子比特的标准排序约定，我们将在下一课中回顾这一点，届时我们将重点关注量子电路。</p>
<h4 id="2-将状态表示为字符串"><a href="#2-将状态表示为字符串" class="headerlink" title="2.将状态表示为字符串"></a>2.将状态表示为字符串</h4><p>N为了简洁起见，<strong>通常将经典状态(a1,…,an) 写为字符串a1⋯an很方便</strong>，特别是在经典状态集Σ1,…,Σn 与符号或字符集相关联（非常典型）的情况下。</p>
<p>事实上，字符串的概念是计算机科学中一个非常重要的概念，它通过笛卡尔积以数学术语形式化。<strong>字母表一词通常用于指代用于形成字符串的符号集</strong>，但字母表的数学定义与经典状态集的定义完全相同：它是一个有限且非空的集合。</p>
<p>例如，假设X1,…,X10都是比特，那么这些系统的经典状态集都是相同的。<br>$$<br>\Sigma_1 &#x3D; \Sigma_2 &#x3D; \cdots &#x3D; \Sigma_{10} &#x3D; {0, 1}<br>$$<br>集合{01} 通常称为二进制字母表。）那么联合系统 (X1,…,X10) 有2^10&#x3D;1024 个经典状态，它们是集合Σ1×Σ2×⋯×Σ10&#x3D;{0,1}<br>$$<br>\Sigma_1 &#x3D; \Sigma_2 &#x3D; \cdots &#x3D; \Sigma_{10} &#x3D; \left{ { 0, 1 }^{10} \right}<br>$$<br>这些经典状态如果写成字符串，则如下所示：</p>
<p>0000000000<br>0000000001<br>0000000001<br>0000000011<br>0000000100<br>⋮<br>1111111111</p>
<p><strong>例如，对于经典状态0001010000，我们看到X4和X6处于状态1,1，而所有其他系统都处于状态0.</strong></p>
<h4 id="3-概率状态"><a href="#3-概率状态" class="headerlink" title="3.概率状态"></a>3.概率状态</h4><p>回想一下上一课，概率状态将概率与系统的每个经典状态相关联。因此，<strong>多个系统的概率状态（将它们视为一个系统）将概率与各个系统的经典状态集的笛卡尔积的每个元素相关联</strong>。</p>
<p>例如，假设X 和Y 都是比特，那么它们对应的经典状态集分别为<br>Σ&#x3D;{0,1} 和Γ&#x3D;{0,1}。以下是对的概率状态：(X,Y):<br>$$<br>\Pr\left( (X,Y) &#x3D; (0,0) \right) &#x3D; \frac{1}{2} \<br>\Pr\left( (X,Y) &#x3D; (0,1) \right) &#x3D; 0 \<br>\Pr\left( (X,Y) &#x3D; (1,0) \right) &#x3D; 0 \<br>\Pr\left( (X,Y) &#x3D; (1,1) \right) &#x3D; \frac{1}{2}<br>$$</p>
<p>此概率状态是X 和Y 都是随机位 — 每一个都以概率1&#x2F;2 为0 并以概率1&#x2F;2 为1 — 但两个位的经典状态始终一致。这是这些系统之间相关性的一个例子。</p>
<h5 id="排序笛卡尔积状态集"><a href="#排序笛卡尔积状态集" class="headerlink" title="排序笛卡尔积状态集"></a>排序笛卡尔积状态集</h5><p>系统的概率状态由概率向量表示，<strong>概率向量是列向量</strong>，其索引与所考虑系统的底层经典状态集相对应。对于多个系统也会出现同样的情况。<strong>要将多个系统的概率状态表示为笛卡尔积，必须确定乘积元素的顺序</strong>。假设系统X,Y 的各个经典状态集Σ,Γ 已经排序，有一个简单的惯例：按字母顺序排列。更准确地说，<strong>每个n 元组中的条目（或等效地，每个字符串中的符号）被视为按从左到右的重要性递减排序</strong>。</p>
<p>例如，按照此约定，笛卡尔积{1,2,3}×{0,1} 的排序如下：<br>$$<br>{(1, 0), (1,1),(2, 0),(2,1),(3,0),(3,1 )}<br>$$<br>当n 元组被写成字符串并以此方式排序时，我们会观察到熟悉的模式，例如{0,1}×{0,1} 被排序为00,01,10,11，以及集合{0,1}^10被按上述建议排序。我们还看到{0,1,…,9}×{0,1,…,9} 被排序为数字0 到99.。您可能意识到这并非巧合：当今的十进制数字系统使用相同的字母顺序。当然，这里的“字母”具有更广泛的含义，可能包括一组数字符号。</p>
<p>回到上面的两位示例，概率状态由以下概率向量表示（其中条目已明确标记，以便清晰起见）。<br>$$<br>\begin{pmatrix}<br>\frac{1}{2} &amp; \text{←probability associated with state 00}\<br>0  &amp; \text{←probability associated with state 01}\<br>0 &amp; \text{←probability associated with state 10}\<br>\frac{1}{2} &amp; \text{←probability associated with state 11}<br>\end{pmatrix}<br>$$</p>
<h5 id="两个系统独立"><a href="#两个系统独立" class="headerlink" title="两个系统独立"></a>两个系统独立</h5><p><strong>两个系统的一种特殊概率状态是系统独立。</strong>直观地说，如果了解任一系统的经典状态对与另一个系统相关的概率没有影响，则两个系统是独立的。也就是说，了解其中一个系统处于哪种经典状态并不能提供有关另一个系统经典状态的任何信息。</p>
<p>为了准确定义这个概念，让我们再次假设X 和Y 是分别具有经典状态集Σ 和Γ 的系统。对于这些系统的给定概率状态，<strong>如果满足以下条件，则称它们是独立的</strong><br>$$<br>Pr(X,Y)&#x3D;(a,b))&#x3D;Pr(X &#x3D; a)Pr(Y &#x3D; b)  \quad\quad\quad\quad (1)<br>$$<br>或每个选择a∈Σ 和b∈Γ.</p>
<p>为了用概率向量来表达这个条件，假设给定的概率状态(X,Y) 由一个概率向量描述，用狄拉克符号表示为<br>$$<br>\sum_{(a,b)\in Σ\timesΓ}|ab\rangle\quad(2)<br>$$<br>独立性条件(2) 等同于存在两个概率向量<br>$$<br>∣ϕ⟩&#x3D;\sum _{a \in Σ}q_a∣a\rangle \quad\text{and}\quad∣ψ\rangle&#x3D;\sum _{b \in Γ} r_b∣b\rangle \quad(3)<br>$$</p>
<p>分别表示与X 和Y的经典状态相关的概率，使得<br>$$<br>p_{ab} &#x3D; q_ar_b \quad(4)<br>$$<br>对于所有a∈Σ和b∈Γ。</p>
<p>例如，由向量</p>
<p>$$<br> \frac{1}{6}∣00⟩+ \frac{1}{12}∣01⟩+ ∣\frac{1}{2}10⟩+\frac{1}{4}∣11⟩<br>$$<br>表示的一对比特(X,Y)的概率状态是X和Y是独立的。具体来说，独立性所需的条件对于概率向量为真</p>
<p>$$<br>∣ϕ⟩&#x3D; \frac{1}{4}∣0⟩+ \frac{3}{4}∣1⟩\quad and \quad∣ψ⟩&#x3D; \frac{2}{3}∣0⟩+ \frac{1}{3}∣1⟩.<br>$$</p>
<p>例如，为了匹配00 条目，我们需要1&#x2F;6 &#x3D; 1&#x2F;4 + 2&#x2F;3,事实确实如此。其他条目</p>
<p>可以用类似的方式验证。</p>
<p>另一方面，概率状态<br>(1)，我们可以写成<br>$$<br>\frac{1}{2}|00\rangle + \frac{1}{2}|11\rangle \quad (5)<br>$$<br>并不表示系统X 和Y 之间的独立性。一个简单的论证方法如下。</p>
<p>假设确实存在概率向量∣ϕ⟩ 和∣ψ⟩，如上式(3) 所示，对于每个a 和b 的选择，条件(4) 都得到满足。那么必然有<br>$$<br>q_0 r_1 &#x3D;Pr((X,Y)&#x3D;(0,1))&#x3D;0.<br>$$<br>这意味着要么q0&#x3D;0 要么r1&#x3D;0，因为如果两者都不为零，则乘积q0r1也不会为零。这导致以下结论：要么q0r0&#x3D;0（如果r1&#x3D;0）。然而，我们发现这两个等式都不成立，因为我们必须有r0&#x3D;1&#x2F;2 和q1r1&#x3D;1&#x2F;2。因此，不存在满足独立性所需属性的向量∣ϕ⟩ 和∣ψ⟩。</p>
<p>定义了两个系统之间的独立性后，我们现在可以将相关性精确定义为缺乏独立性。例如，由于向量(5) 表示的概率状态中的两个位不是独立的，因此根据定义，它们是相关的。</p>
<h5 id="向量的张量积"><a href="#向量的张量积" class="headerlink" title="向量的张量积"></a>向量的张量积</h5><p>刚刚描述的独立性条件可以通过张量积的概念更简洁地表达。虽然这是一个非常普遍的概念，可以非常抽象地定义并应用于各种数学结构，但在当前情况下，它可以用简单、具体的术语来定义。给定两个向量</p>
<p><img src="/./../../images/Qiskit/Day01/01.png"></p>
<p>张量积∣ϕ⟩⊗∣ψ⟩ 是联合状态集上的一个新向量Σ×Γ，定义为</p>
<p><img src="/./../../images/Qiskit/Day01/02.png"></p>
<p>等价地，向量∣π⟩&#x3D;∣ϕ⟩⊗∣ψ⟩ 由以下方程定义</p>
<p><img src="/./../../images/Qiskit/Day01/03.png"></p>
<p>对于每个a∈Σ 和b∈Γ都成立。</p>
<p>我们现在可以重新定义独立性条件，要求联合系统(X,Y) 的概率向量∣π⟩ 可以表示为张量积</p>
<p><img src="/./../../images/Qiskit/Day01/04.png"></p>
<p>概率向量∣ϕ⟩ 和∣ψ⟩ 在每个子系统X 和Y上。在这种情况下，我们称∣π⟩ 为乘积状态或乘积向量。</p>
<p>在对 kets 进行张量积时，我们经常省略符号⊗，例如写成∣ϕ⟩∣ψ⟩ 而不是∣ϕ⟩⊗∣ψ⟩。这种惯例体现了这样一种思想：在这种情况下，张量积是取两个向量乘积的最自然或默认方式。虽然不太常见，但有时也会使用符号∣ϕ⊗ψ⟩。</p>
<p>当我们使用字母约定对笛卡尔积的元素进行排序时，我们得到两个列向量的张量积的以下规范。</p>
<p><img src="/./../../images/Qiskit/Day01/05.png"></p>
<p>另外，我们观察到标准基向量张量积的以下表达式：</p>
<p><img src="/./../../images/Qiskit/Day01/06.png"></p>
<p>或者，将(a,b) 写成有序对而不是字符串，我们可以写成</p>
<p><img src="/./../../images/Qiskit/Day01/07.png"></p>
<p><strong>但更常见的写法是</strong></p>
<p><img src="/./../../images/Qiskit/Day01/08.png"></p>
<p>遵循数学中的一种做法，即删除那些不会增加清晰度或消除歧义的括号。</p>
<p>两个向量的张量积具有重要的双线性特性，这意味着它在两个参数中都是线性的，假设另一个参数是固定的。此属性可以通过以下方程表示：</p>
<ol>
<li><p>第一个参数的线性：</p>
<p><img src="/./../../images/Qiskit/Day01/09.png"></p>
</li>
<li><p>第二个参数的线性：</p>
</li>
</ol>
<p><img src="/./../../images/Qiskit/Day01/10.png"></p>
<p>考虑每对方程中的第二个方程，我们看到标量在张量积内“自由浮动”：</p>
<p><img src="/./../../images/Qiskit/Day01/11.png"></p>
<p>因此，简单地写成α∣ϕ⟩⊗∣ψ⟩，或者写成α∣ϕ⟩∣ψ⟩ 或α∣ϕ⊗ψ⟩，来指代该向量，不会产生歧义。</p>
<h5 id="三个或更多系统的独立性和张量积"><a href="#三个或更多系统的独立性和张量积" class="headerlink" title="三个或更多系统的独立性和张量积"></a>三个或更多系统的独立性和张量积</h5><p>独立性和张量积的概念可直接推广到三个或更多系统。如果X1,…,Xn分别是具有经典状态集Σ1,…,Σn的系统，则组合系统(X1,…,Xn)的概率状态为乘积状态，如果相关概率向量采用以下形式</p>
<p><img src="/./../../images/Qiskit/Day01/12.png"></p>
<p>对于概率向量∣ϕ1⟩,…,∣ϕn⟩ 描述概率状态X1,…,Xn.</p>
<p>这里，张量积的定义以一种自然的方式推广：向量</p>
<p><img src="/./../../images/Qiskit/Day01/13.png"></p>
<p>由方程定义</p>
<p><img src="/./../../images/Qiskit/Day01/14.png"></p>
<p>对于每个a1∈Σ1,…an∈Σn都成立。定义三个或更多向量的张量积的一种不同但等效的方法是递归地用两个向量的张量积来表示：</p>
<p><img src="/./../../images/Qiskit/Day01/15.png"></p>
<p>假设n≥3。</p>
<p>与仅两个向量的张量积类似，假设所有其他参数都是固定的，则三个或更多个向量的张量积在每个参数中都是线性的。在这种情况下，我们说三个或更多个向量的张量积是多线性的。</p>
<p>就像我们在两个系统的情况下所做的那样，我们可以说系统X1,…,Xn在乘积状态时是独立的，但术语“相互独立”更准确。对于三个或更多系统，恰好还有其他独立性概念，例如成对独立性，我们目前不会关注这些概念。</p>
<p>概括先前关于标准基向量张量积的观察，对于任何正整数n 和任何经典状态a1,…,an</p>
<p>我们有</p>
<p><img src="/./../../images/Qiskit/Day01/16.png"></p>
<h3 id="概率状态的测量"><a href="#概率状态的测量" class="headerlink" title="概率状态的测量"></a>概率状态的测量</h3><p>现在让我们继续讨论多系统概率状态的测量。通过选择将多个系统一起视为单个系统，我们立即获得了多系统测量必须如何工作的规范——前提是所有系统都经过测量。</p>
<p>例如，如果两位(X,Y) 的概率状态由概率向量描述</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/01.png"></p>
<p>然后以概率 1&#x2F;2 获得结果00 — 即测量X 时为0，测量Y 时为0 — 并且以概率 1&#x2F;2 获得结果<br>11。在每种情况下，我们都会相应地更新我们知识的概率向量描述，以便概率状态分别变为∣00⟩ 或∣11⟩。</p>
<h4 id="部分测量"><a href="#部分测量" class="headerlink" title="部分测量"></a>部分测量</h4><p>但是，假设我们选择不测量每个系统，而是只测量系统的某些适当子集。这将为每个被测量的系统产生一个测量结果，并且（一般来说）也会影响我们对其余系统的了解。</p>
<p>让我们关注两个系统的情况，其中一个系统被测量。更一般的情况——测量三个或更多系统的某个适当子集——当我们将集体测量的系统视为一个系统，将未测量的系统视为第二个系统时，实际上可以归结为两个系统的情况。</p>
<p>准确地说，让我们（像往常一样）假设X 是一个具有经典状态集Σ 的系统，Y 是一个具有经典状态集Γ 的系统，并且两个系统一起处于某种概率状态。我们将考虑当我们只测量X 而不对Y做任何事情时会发生什么。仅测量Y 而X没有任何变化的情况是对称处理的。</p>
<p>首先，我们知道，当仅测量X 时，观察到特定经典状态a∈Σ 的概率必须与我们在假设Y 也被测量的情况下获得的概率一致。也就是说，我们必须有</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/02.png"></p>
<p>这是所谓的仅 X 的简化（或边际）概率状态的公式。</p>
<p>从直观层面来看，这个公式完全合理；只有发生一些非常奇怪的事情，它才会出错。这意味着 X测量的概率仅受 Y是否也进行测量的影响，而与 Y 的结果无关。如果 Y恰好位于遥远的位置，比如另一个星系，这将允许超光速信号，但根据我们对物理学的理解，我们拒绝这种信号。另一种理解方式是将概率解释为反映对系统状态的信念程度。由于对 Y 的测量只是为了揭示预先存在的状态，因此观察 X的另一个观察者不知道 Y的测量，因此他们的概率不应该改变。</p>
<p>假设只有X 被测量而Y 未被测量，那么对于Y 的经典状态，通常仍可能存在不确定性。因此，对于a∈Σ 和,b∈Γ 中的某些选择，我们不必将(X,Y) 的概率状态描述更新为∣ab⟩，而是必须更新我们的描述，以便正确反映关于Y 的不确定性。</p>
<p>下面的条件概率公式反映了这种不确定性。</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/03.png"></p>
<p>这里，表达式Pr(Y&#x3D;b∣X&#x3D;a) 表示Y&#x3D;b 的概率，条件是（或假设）X&#x3D;a.需要注意的是，上面的表达式只有在Pr(X&#x3D;a) 非零时才有定义，因为如果</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/04.png"></p>
<p>么我们得到不定式0&#x2F;0。不过这不是问题，因为如果与a 相关的概率为零，那么我们永远不会观察到a 作为测量X 的结果，所以我们不需要担心这种可能性。</p>
<p>为了用概率向量来表达这些公式，请考虑一个概率向量∣ψ⟩，它描述(X,Y) 的联合状</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/05.png"></p>
<p>测量X 单独产生每个可能结果的概率</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/06.png"></p>
<p>因此，表示X 的概率状态（即X 的简化概率状态）的向量由下式给出：</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/07.png"></p>
<p>在获得 X 的测量结果a∈Σ 后，Y 的概率状态将根据条件概率公式进行更新，从而可以用以下概率向量表示：</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/08.png"></p>
<p>如果 X 的测量结果为经典状态 a,那么我们将联合系统 (X,Y) 的概率状态描述更新为 ∣a⟩⊗∣πa⟩. . 思考 ∣πa⟩ 的这个定义的一种方法是将其视为向量 ∑b∈Γpab∣b⟩ 的归一化，其中我们除以该向量中条目的总和以获得概率向量。这种规范化有效地解释了对X 的测量导致结果a的事件的条件。<strong>举一个具体的例子，假设X 的经典状态集为Σ&#x3D;{0,1}，Y 的经典状态集为Γ&#x3D;{1,2,3}，(X,Y) 的概率状态为</strong></p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/09.png"></p>
<p>我们的<strong>目标是确定两种可能结果（0 和1）的概率，并计算Y 的最终概率状态对于这两种结果的假设，</strong>假设系统X 是可测量的。利用张量积的双线性，特别是它在第二个参数中是线性的事实，我们可以将向量∣ψ⟩ 重写如下：</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/10.png"></p>
<p>我们已经分离出被测系统的不同标准基向量，并将第二个系统的所有项收集在一起。稍加思考就会发现，无论我们从哪个向量开始，这都是可能的。</p>
<p>经过这样的重组，测量结果变得易于分析。两个结果的概率由下式给出：</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/11.png"></p>
<p>请注意，这些概率之和与预期一致，这对我们的计算结果进行了有用的检查。</p>
<p>此外，<strong>以每种可能结果为条件的Y 的概率状态也可以通过对括号中的向量进行归一化（除以刚刚计算的相关概率）来快速推断，从而使这些向量成为概率向量。</strong>也就是说，以X 为0 为条件，Y 的概率状态变为</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/12.png"></p>
<p>并且以X 的测量值为 1 为条件，Y 的概率状态变为</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/13.png"></p>
<h4 id="概率状态的操作"><a href="#概率状态的操作" class="headerlink" title="概率状态的操作"></a>概率状态的操作</h4><p>为了结束对多系统经典信息的讨论，我们将考虑在概率状态下对多系统进行的操作。按照我们对概率状态和测量的相同想法，我们可以将多个系统视为形成单个复合系统，并查看上一课以了解其工作原理。</p>
<p>回到典型的设置，我们有两个系统X 和Y，让我们考虑对复合系统(X,Y) 进行经典操作。根据上一课和上面的讨论，我们得出结论，任何此类操作都由一个随机矩阵表示，其行和列由笛卡尔积</p>
<p>Σ×Γ</p>
<p>如果 X&#x3D;1，则对 Y执行 NOT 运算。<br>否则不执行任何操作。</p>
<p><strong>这是一个确定性操作，称为受控非操作，其中X 是控制位，用于确定是否应对目标位进行非操作Y以下是此操作的矩阵表示：</strong></p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/14.png"></p>
<p>其动作标准如下。</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/15.png"></p>
<h5 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h5><p><img src="/./../../images/Qiskit/Day02/03.jpg"></p>
<p><strong>如果我们交换X 和Y 的角色，以Y 为控制位，X 为目标位，则该操作的矩阵表示将变成</strong></p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/16.png"></p>
<p>另一个示例是具有以下描述的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行以下两个操作之一，每个操作的概率为1/2:</span><br><span class="line"></span><br><span class="line">设置Y 等于X.</span><br><span class="line"></span><br><span class="line">设置X 等于Y.</span><br></pre></td></tr></table></figure>

<p>该操作的矩阵表示如下：</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/17.png"></p>
<p>该操作对标准基向量的作用如下：</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/18.png"></p>
<p>在这些示例中，我们只是将两个系统视为一个系统，并按照上一课中的方式进行操作。</p>
<p><strong>对于任意数量的系统，都可以执行相同的操作</strong>。例如，假设我们有三位，我们将三位以<br>8为模数递增 - 这意味着我们将三位视为使用二进制表示法对 0和 7 之间的数字进行编码，添加 1，然后除以 8 后取余数。我们可以像这样编写此操作：</p>
<p><img src="/./../../images/%E9%87%8F%E5%AD%90%C2%B7%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E5%9B%BE/Day01/19.png"></p>
<p>我们也可以写为如下形式：</p>
<p><img src="/./../../images/Qiskit/Day02/01.png"></p>
<p>假设我们已经同意，一个 ket 中的数字j∈{0,1,…,7} 指的是该数字的三位二进制编码。第三个选项是将此操作表示为矩阵。</p>
<p><img src="/./../../images/Qiskit/Day02/02.png"></p>
<h4 id="独立操作"><a href="#独立操作" class="headerlink" title="独立操作"></a>独立操作</h4><p>现在假设我们有多个系统，并且我们独立地对系统执行单独的操作。</p>
<p>例如，以我们通常设置的两个系统X 和Y 分别具有经典状态集Σ 和Γ 为例，假设我们对X 执行一个操作，并且完全独立地对Y 执行另一个操作。正如我们从上一课中所知，这些操作由随机矩阵表示 - 准确地说，我们说对X 的操作由矩阵M 表示，对Y 的操作由矩阵N 表示。因此，M 的行和列具有与Σ 元素相对应的索引，同样，N 的行和列对应于Γ 的元素。</p>
<p><strong>一个自然而然的问题是：如果我们将X 和Y 视为一个单一的复合系统(X,Y)，那么代表这两个运算对这个复合系统的组合作用的矩阵是什么？</strong>要回答这个问题，我们必须首先引入矩阵的张量积——它类似于向量的张量积，定义类似。</p>
<h4 id="矩阵的张量积"><a href="#矩阵的张量积" class="headerlink" title="矩阵的张量积"></a>矩阵的张量积</h4><p>矩阵的张量积M⊗N</p>
<p><img src="/./../../images/Qiskit/Day02/03.png"></p>
<p>对于a,b∈Σ 和c,d∈Γ 的每个选择都为真。</p>
<p>描述M⊗N 的另一种但等效的方法是，它是满足方程的唯一矩阵</p>
<p><img src="/./../../images/Qiskit/Day02/04.png"></p>
<p>对于每个可能的向量选择∣ϕ⟩ 和∣ψ⟩。这里我们假设∣ϕ⟩ 的索引对应于Σ 的元素，而ψ⟩ 的索引对应于Γ。</p>
<p>按照前面描述的对笛卡尔积元素进行排序的惯例，我们还可以明确地将两个矩阵的张量积写成如下形式：</p>
<p><img src="/./../../images/Qiskit/Day02/05.png">三个或更多矩阵的张量积以类似的方式定义。如果M1,…,Mn是其索引对应于经典状态集<br>Σ1,…,Σn的矩阵，则张量积M1⊗⋯⊗Mn</p>
<p>由以下条件定义</p>
<p><img src="/./../../images/Qiskit/Day02/06.png">对于每个经典状态的选择a1,b1∈Σ1,…,an,bn∈Σn.</p>
<p>或者，我们也可以递归地定义三个或更多矩阵的张量积，即两个矩阵的张量积，类似于我们在向量中观察到的。</p>
<p><strong>矩阵的张量积有时被称为乘法，因为方程</strong></p>
<p><img src="/./../../images/Qiskit/Day02/07.png">对于任何矩阵M1,…,Mn和N1,…,Nn的选择，只要乘积M1N1,…,MnNn有意义，则始终为真。</p>
<p>总结以上讨论，我们发现，如果M 是对X,N 的概率运算，并且这两个运算独立执行，则对复合系统(X,Y) 的最终运算是张量积M⊗N.</p>
<p>我们在这里和概率状态中看到的是，<strong>张量积表示独立性：如果我们有两个系统X 和Y 分别处于概率状态∣ϕ⟩ 和∣π⟩，那么复合系统(X,Y) 处于概率状态∣ϕ⟩⊗∣π⟩；如果我们分别将概率运算M 和N 分别应用于这两个系统，那么对复合系统(X,Y) 产生的作用由运算M⊗N描述。</strong> </p>
<p>让我们看一个例子，它回顾上一课中对单个位的概率操作：如果位的经典状态是0，则保持不变；如果位的经典状态是1，则以1&#x2F;2 的概率将其翻转为 0。正如我们所观察到的，此操作由矩阵表示</p>
<p><img src="/./../../images/Qiskit/Day02/08.png"></p>
<p>如果对位X 执行此操作，并且（独立地）对第二位Y 执行 NOT 操作，则复合系统(X,Y) 上的联合操作具有矩阵表示</p>
<p><img src="/./../../images/Qiskit/Day02/09.png"></p>
<p>通过检查，我们发现这是一个随机矩阵。</p>
<p>情况总是如此：<strong>两个或多个随机矩阵的张量积总是随机的。</strong></p>
<p>我们遇到的一种常见情况是，在一个系统上执行一项操作，而对另一个系统不执行任何操作。在这种情况下，遵循完全相同的规定，注意不执行任何操作由单位矩阵表示。例<strong>如，将位X 重置为</strong><br><strong>0 状态，而对Y 不执行任何操作，将产生由矩阵表示的对(X,Y) 的概率（实际上是确定性的）操作</strong></p>
<p><img src="/./../../images/Qiskit/Day02/10.png"></p>
<h3 id="量子信息"><a href="#量子信息" class="headerlink" title="量子信息"></a>量子信息</h3><p>现在我们准备继续讨论多系统环境下的量子信息。与上一课关于单系统的课程非常相似，多系统量子信息的数学描述与概率情况非常相似，并使用了类似的概念和技术。</p>
<h4 id="量子状态"><a href="#量子状态" class="headerlink" title="量子状态"></a>量子状态</h4><p>可以将多个系统集体视为单个复合系统。我们已经在概率设置中观察到了这一点，量子设置也类似。</p>
<p>也就是说，多个系统的量子态由具有复数项和欧几里得范数等于1 的列向量表示——就像单个系统的量子态一样。在多系统情况下，这些向量的索引与与每个单独系统相关的经典状态集的笛卡尔积相对应（因为这是复合系统的经典状态集）。</p>
<p>例如，如果X 和Y 是量子比特，那么将量子比特对(X,Y) 的经典状态集集体视为单个系统，是笛卡尔积{0,1}×{0,1}。通过将二进制值对表示为长度为 2 的二进制字符串，我们将此笛卡尔积集与集合{00,01,10,11} 相关联。因此，以下向量都是对的量子态向量的示例(X,Y)：</p>
<p><img src="/./../../images/Qiskit/Day02/11.png"></p>
<p>多个系统的量子态向量的表达方式有多种变化，我们可以选择适合自己喜好的变化。下面是一些示例，针对的是上面的第一个量子态向量。</p>
<ol>
<li>我们可以利用以下事实：∣ab⟩&#x3D;∣a⟩∣b⟩（对于任何经典状态a 和b）来代替写作</li>
</ol>
<p><img src="/./../../images/Qiskit/Day02/12.png"></p>
<ol start="2">
<li>我们可以选择像这样明确地写出张量积符号：</li>
</ol>
<p><img src="/./../../images/Qiskit/Day02/13.png"></p>
<ol start="3">
<li>我们可以对 kets 进行下标，以表明它们与正在考虑的系统的对应关系，如下所示：</li>
</ol>
<p><img src="/./../../images/Qiskit/Day02/14.png"></p>
<p>当然，我们也可以把量子态向量明确地写成列向量：</p>
<p><img src="/./../../images/Qiskit/Day02/15.png"></p>
<p>根据其出现的上下文，其中一种变体可能是首选 - 但它们都是等效的，因为它们描述的是同一个向量。</p>
<h5 id="量子态向量的张量积"><a href="#量子态向量的张量积" class="headerlink" title="量子态向量的张量积"></a>量子态向量的张量积</h5><p>与概率向量类似，量子态向量的张量积也是量子态向量——它们再次代表了系统之间的独立性。</p>
<p>更详细地说，从两个系统的情况开始，假设∣ϕ⟩ 是系统X 的量子态向量，而∣ψ⟩ 是系统Y的量子态向量。∣ϕ⟩⊗∣ψ⟩，也可以写成∣ϕ⟩∣ψ⟩ 或∣ϕ⊗ψ⟩，则是联合系统X,Y的量子态向量。（X,Y）。我们将这种形式的状态称为乘积状态。</p>
<p>直观地说，当一对系统(X,Y) 处于乘积状态∣ϕ⟩⊗∣ψ⟩ 时，我们可以将其解释为X 处于量子态∣ϕ⟩，<br>Y 处于量子态∣ψ⟩，并且两个系统的状态彼此无关。</p>
<p>张量积向量∣ϕ⟩⊗∣ψ⟩ 确实是量子态向量，这与欧几里得范数关于张量积的乘法性一致：</p>
<p><img src="/./../../images/Qiskit/Day02/16.png"></p>
<p>因此，因为∣ϕ⟩ 和∣ψ⟩ 是量子态向量，我们有∥∣ϕ⟩∥&#x3D;1 和∥∣ψ⟩∥&#x3D;1，因此∥∣ϕ⟩⊗∣ψ⟩∥&#x3D;1，所以<br>∣ϕ⟩⊗∣ψ⟩ 也是一个量子态向量。这个讨论可以推广到两个以上的系统。如果∣ψ1⟩,…,∣ψn⟩ 是系统X1,…,Xn的量子态向量，则∣ψn⟩∣ψ1⟩⊗⋯⊗∣ψn⟩ 是表示联合系统(X1,…,Xn) 的乘积状态的量子态向量。再次，我们知道这是一个量子态矢量，因为</p>
<p><img src="/./../../images/Qiskit/Day02/17.png"></p>
<h5 id="纠缠态"><a href="#纠缠态" class="headerlink" title="纠缠态"></a>纠缠态</h5><p>并非所有多系统量子态向量都是乘积态。例如，量子态向量</p>
<p><img src="/./../../images/Qiskit/Day02/18.png"></p>
<p>两个量子比特的 不是乘积状态。为了推理这一点，我们可以遵循与证明向量(5) 表示的概率状态不是乘积状态完全相同的论证。</p>
<p>也就是说，如果(6) 是乘积状态，则存在量子态向量∣ϕ⟩ 和∣ψ⟩，其中</p>
<p><img src="/./../../images/Qiskit/Day02/19.png"></p>
<p>但这样一来，</p>
<p><img src="/./../../images/Qiskit/Day02/20.png"></p>
<p>这意味着⟨0∣ϕ⟩&#x3D;0 或⟨1∣ψ⟩&#x3D;0（或两者）。这与以下事实相矛盾：</p>
<p><img src="/./../../images/Qiskit/Day02/21.png"></p>
<p>请注意，具体值1&#x2F;2^(1&#x2F;2)对这个论点并不重要——重要的是这个值不为零。因此，例如，量子态</p>
<p><img src="/./../../images/Qiskit/Day02/22.png"></p>
<p>根据同样的论点，也不是产品状态。</p>
<p>因此，量子态向量(6) 表示两个系统之间的相关性，具体来说，我们称这两个系统是纠缠的。</p>
<p>纠缠是量子信息的一个典型特征，将在后面的课程中更详细地讨论。纠缠可能很复杂，特别是对于可以在第 1 课中提到的量子信息的一般密度矩阵公式中描述的噪声量子态，但对于我们在本单元中关注的简化公式中的量子态向量，纠缠等同于相关性。也就是说，任何不是乘积向量的量子态向量都表示纠缠态。</p>
<p>相反，量子态矢量</p>
<p><img src="/./../../images/Qiskit/Day02/23.png"></p>
<p>是产品状态的一个例子：</p>
<p><img src="/./../../images/Qiskit/Day02/24.png"></p>
<p>因此，这个态是非纠缠的。</p>
<h5 id="Bell-states"><a href="#Bell-states" class="headerlink" title="Bell states"></a>Bell states</h5><p>现在，我们将从贝尔态开始，介绍一些多量子比特量子态的重要示例。以下是四个双量子比特状态：</p>
<p><img src="/./../../images/Qiskit/Day02/25.png"></p>
<p>贝尔态以约翰·贝尔 (John Bell) 的名字命名。</p>
<p>请注意，同样的论证证明了∣ϕ+⟩ 不是乘积态，这表明其他贝尔态也不是乘积态——所有四个贝尔态都代表两个量子比特之间的纠缠。</p>
<p>所有四个贝尔态的集合</p>
<p><img src="/./../../images/Qiskit/Day02/26.png"></p>
<p>被称为贝尔基；任何两个量子比特的量子态向量，或者任何具有与两个比特的四个经典状态相对应的条目的复向量，都可以表示为四个贝尔态的线性组合。例如，</p>
<p><img src="/./../../images/Qiskit/Day02/27.png"></p>
<h5 id="GHZ-and-W-states"><a href="#GHZ-and-W-states" class="headerlink" title="GHZ and W states"></a>GHZ and W states</h5><p>接下来，我们将考虑两个有趣的三量子比特状态示例。</p>
<p>我们将考虑的第一个示例代表三个量子比特的量子（X，Y，Z），是 GHZ 状态（以 Daniel Greenberger、Michael Horne 和 Anton Zeilinger 的名字命名，他们首先研究了它的一些特性）：</p>
<p><img src="/./../../images/Qiskit/Day02/28.png"></p>
<p>第二个例子是所谓的 W 状态</p>
<p><img src="/./../../images/Qiskit/Day02/29.png"></p>
<p>这两种状态都不是乘积状态，这意味着它们不能写成三个量子比特量子态向量的张量积。</p>
<p>当我们讨论多个系统的量子态的部分测量时，我们将进一步研究这两种状态。</p>
<h5 id="Additional-examples"><a href="#Additional-examples" class="headerlink" title="Additional examples"></a>Additional examples</h5><p>到目前为止，我们看到的多系统量子态的例子是两个或三个量子比特的状态，但我们也可以拥有具有不同经典状态集的多系统量子态。</p>
<p>例如，这里有一个由三个系统组成的量子态，X,Y 和Z，其中X 的经典状态集是二进制字母表（因此X 是一个量子位），而Y 和Z 的经典状态集是{♣,♢,♡,♠}:</p>
<p><img src="/./../../images/Qiskit/Day02/30.png"></p>
<p>下面是三个系统量子态的示例(X,Y,Z)，其中（X,Y Z ）都共享相同的经典状态集{0,1,2}:</p>
<p><img src="/./../../images/Qiskit/Day02/31.png"></p>
<p>具有经典状态集{0,1,2} 的系统通常称为三态系统，或者，假设我们考虑它们处于量子态的可能性，则称为量子三态系统。术语量子态系统是指具有经典状态集{0,…,d−1} 的系统，其中d为任意值。</p>
<h6 id="理解笔记"><a href="#理解笔记" class="headerlink" title="理解笔记"></a>理解笔记</h6><h4 id="量子状态的测量"><a href="#量子状态的测量" class="headerlink" title="量子状态的测量"></a>量子状态的测量</h4><h4 id="酉操作"><a href="#酉操作" class="headerlink" title="酉操作"></a>酉操作</h4><p>在本课的前面部分中，我们使用笛卡尔积将各个系统视为一个更大的单一系统。按照同样的思路，我们可以将多个系统上的操作表示为作用于这个更大系统的状态向量的酉矩阵。</p>
<p>原则上，任何行和列对应于我们正在考虑的任何系统的经典状态的酉矩阵都代表一个有效的量子操作——这适用于经典状态集恰好是各个系统的经典状态集的笛卡尔积的复合系统。</p>
<p>关注两个系统，如果X 是一个具有经典状态集Σ 的系统，而Y 是一个具有经典状态集Γ 的系统，那么联合系统(X,Y) 的经典状态集为Σ×Γ——因此，可以对该联合系统执行的操作集由行和列与集合Σ×Γ相对应的酉矩阵表示。这些矩阵的行和列的顺序与系统(X,Y) 的量子态向量的顺序相同。</p>
<p>例如，假设Σ&#x3D;{1,2,3} 和Γ&#x3D;{0,1}，并且回想一下，对笛卡尔积{1,2,3}×{0,1} 元素进行排序的标准约定是<br>(1,0),(1,1),(2,0),(2,1),(3,0),(3,1)。以下是表示对(X,Y)进行运算的酉矩阵示例：</p>
<p><img src="/./../../images/Qiskit/Day04/1.png"></p>
<p>这个幺正运算并不重要，它只是一个例子。要检查U 是否为幺正，只需计算：U†U&#x3D;I.</p>
<p>例如，U 对标准基向量∣11⟩ 的作用为</p>
<p><img src="/./../../images/Qiskit/Day04/2.png"></p>
<p>通过检查U 的第二列，我们可以看到，考虑到我们对集合{1,2,3}×{0,1} 的排序。</p>
<p>与任何矩阵一样，可以使用狄拉克符号表示U ，其中 20 个项表示U 的 20 个非零项。但是，如果我们写下所有这些项，而不是写一个6×6 矩阵，我们可能会错过矩阵表达式中明显的某些模式。简而言之，狄拉克符号并不总是表示矩阵的最佳选择。</p>
<p>三个或更多系统上的酉运算以类似的方式工作，酉矩阵的行和列对应于系统经典状态集的笛卡尔积。</p>
<p>我们已经在本课中看到了一个例子：三量子比特运算</p>
<p>从前面可以看出，其中∣j⟩ 表示数字j 的三位二进制编码是酉的。既是酉的又表示确定性运算的运算称为可逆运算。该矩阵的共轭转置可以写成这样：</p>
<p><img src="/./../../images/Qiskit/Day04/3.png"></p>
<p>这个矩阵表示原始运算的逆，或者用数学术语来说就是逆，这就是我们对酉矩阵的共轭转置的期望。</p>
<p>随着课程的继续，我们将看到多个系统上酉运算的其他示例。</p>
<h5 id="在各个系统上独立执行的单元操作"><a href="#在各个系统上独立执行的单元操作" class="headerlink" title="在各个系统上独立执行的单元操作"></a>在各个系统上独立执行的单元操作</h5><p>当对一组单个系统独立执行酉运算时，这些独立运算的组合作用由表示它们的酉矩阵的张量积描述。也就是说，如果X1,…,Xn是量子系统，U1,…,Un是表示对这些系统进行操作的酉矩阵，并且这些操作在这些系统上独立执行，则对(X1,…,Xn) 的组合作用由矩阵U1⊗⋯⊗Un表示。我们再次发现，概率和量子设置在这方面是类似的。</p>
<p>从上一段中，人们自然会想到，任何一组酉矩阵的张量积都是酉的。事实上这是正确的，我们可以按如下方式验证它。</p>
<p>首先注意，共轭转置运算满足</p>
<p><img src="/./../../images/Qiskit/Day04/4.png"></p>
<p>或任何矩阵集合M1,…,Mn。这可以通过返回张量积和共轭转置的定义并检查等式两边的每个条目是否一致来检查。这意味着</p>
<p><img src="/./../../images/Qiskit/Day04/5.png"></p>
<p>因为矩阵的张量积是乘法的，我们发现</p>
<p><img src="/./../../images/Qiskit/Day04/6.png"></p>
<p>这里我们写成I1,…,In来表示表示系统X1,…,Xn上的恒等运算的矩阵 — 也就是说，这些恒等矩阵的大小与<br>X1,…,Xn的经典状态数一致。最后，张量积I1⊗⋯⊗In等于单位矩阵，其中行数和列数与矩阵I1,…,In的行数和列数的乘积一致。我们可以将这个较大的单位矩阵视为表示联合系统(X1,…,Xn) 上的恒等运算。</p>
<p>总之，我们有以下等式序列：</p>
<p><img src="/./../../images/Qiskit/Day04/7.png"></p>
<p>因此，我们得出结论：U1⊗⋯⊗Un是酉的。</p>
<p>经常出现的一个重要情况是，在一个较大的联合系统中，酉运算只应用于一个系统（或系统的适当子集）。例如，假设X 和Y 是我们可以一起视为形成单个复合系统(X,Y) 的系统，并且我们只对系统X 执行操作。准确地说，让我们假设U 是一个酉矩阵，表示对X 的操作，因此它的行和列与X的经典状态相对应。<br>说我们只对系统X 执行U 所表示的操作意味着我们对Y 不做任何操作，这意味着我们独立地对X 执行U 并对Y 执行恒等操作。也就是说，对Y “不做任何操作”相当于对Y 执行恒等操作，这由恒等矩阵IY表示。（顺便说一下，下标Y 告诉我们IY指的是具有与Y 的经典状态集一致的行数和列数的恒等矩阵。）因此，当我们对X 执行U 而对Y 不做任何操作时获得的(X,Y) 上的操作由酉矩阵表示</p>
<p><img src="/./../../images/Qiskit/Day04/8.png"></p>
<p>例如，如果X 和Y 是量子比特，则对X 执行 Hadamard 运算（而对Y 不执行任何操作）相当于执行以下运算</p>
<p><img src="/./../../images/Qiskit/Day04/9.png"></p>
<p>在联合系统(X,Y) 上。类似地，我们可以考虑将由酉矩阵U 表示的运算应用于Y ，而对</p>
<p>X 不执行任何操作，在这种情况下，对(X,Y) 的结果运算由酉矩阵IX⊗U 表示。</p>
<p>例如，如果我们再次考虑X 和Y 都是量子比特且U 是 Hadamard 运算的情况，则对(X,Y) 的结果运算由矩阵表示</p>
<p><img src="/./../../images/Qiskit/Day04/10.png"></p>
<p>并非系统集合X1,…,Xn上的每个幺正运算都可以写成幺正运算的张量积U1⊗⋯⊗Un，正如并非这些系统的每个量子态向量都是乘积状态一样。例如，下面描述的交换运算和两个量子位上的受控非运算都不能表示为幺正运算的张量积。</p>
<h5 id="交换操作"><a href="#交换操作" class="headerlink" title="交换操作"></a>交换操作</h5><p>为了结束本课，让我们看一下多系统上两类幺正运算的例子，从交换运算开始。</p>
<p>假设X 和Y 是共享相同经典状态集Σ的系统。(X,Y) 的交换运算是交换两个系统内容的运算，但除此之外，系统保持不变（因此X 保持在左侧，Y 保持在右侧）。</p>
<p>我们将此运算表示为SWAP。对于每个经典状态a,b∈Σ的选择，它都像这样运行：<br><img src="/./../../images/Qiskit/Day04/12.png"></p>
<p>使用狄拉克符号来编写与此运算相关的矩阵的一种方法如下：</p>
<p><img src="/./../../images/Qiskit/Day04/13.png"></p>
<p>可能不是立即清楚该矩阵代表SWAP，但我们可以检查它是否满足条件SWAP∣a⟩∣b⟩&#x3D;∣b⟩∣a⟩，对于每个经典状态的选择a,b∈Σ.</p>
<p>举一个简单的例子，当X 和Y 是量子比特时，我们发现</p>
<p><img src="/./../../images/Qiskit/Day04/14.png"></p>
<h5 id="受控单一运营"><a href="#受控单一运营" class="headerlink" title="受控单一运营"></a>受控单一运营</h5><p>现在让我们假设Q 是一个量子比特，R 是一个任意系统，具有我们希望的任何经典状态集。对于作用于系统R 的每个幺正操作U，受控的U 操作是对对(Q,R) 的幺正操作，定义如下：</p>
<p><img src="/./../../images/Qiskit/Day04/15.png"></p>
<p>例如，如果R 也是一个量子比特，我们考虑对R 进行 PauliX 操作，那么受控的X 操作由以下公式给出</p>
<p><img src="/./../../images/Qiskit/Day04/16.png"></p>
<p>在本课的前面部分，我们已经在经典信息和概率运算的背景下遇到过此运算。</p>
<p>如果我们考虑在 R 上用 PauliZ 运算代替X 运算，我们会得到以下运算：</p>
<p><img src="/./../../images/Qiskit/Day04/17.png"></p>
<p>如果我们取R 为两个量子位，取U 为这两个量子位之间的交换操作，我们会得到以下操作：</p>
<p><img src="/./../../images/Qiskit/Day04/18.png"></p>
<p>此操作也称为 Fredkin 操作（或更常见的是 Fredkin 门），以 Edward Fredkin 命名。其对标准基础状态的操作可描述如下：</p>
<p><img src="/./../../images/Qiskit/Day04/19.png"></p>
<p>最后，受控-受控-非运算，我们可以将其表示为CCX，称为 Toffoli 运算（或 Toffoli 门），以 Tommaso Toffoli 命名。其矩阵表示如下：</p>
<p><img src="/./../../images/Qiskit/Day04/20.png"></p>
<p>我们也可以使用狄拉克符号来表达如下：</p>
<p><img src="/./../../images/Qiskit/Day04/21.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">陈智涛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/12/04/Qiskit%E8%AF%BE%E7%A8%8B/SingleSystem/">http://example.com/2024/12/04/Qiskit%E8%AF%BE%E7%A8%8B/SingleSystem/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">ZTCodeGarden</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/01.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/12/05/%E5%8A%9B%E6%89%A3/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AF%87/LE70%E7%88%AC%E6%A5%BC%E6%A2%AF/" title="LE70爬楼梯"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">LE70爬楼梯</div></div><div class="info-2"><div class="info-item-1">问题 思路(1) 确定dp数组及下标的含义​        dp[i] : 需要i阶才能到达楼顶（从第i层到达地面需要的走法） （2）确定递推公式​            上楼梯问题，不妨转换为下楼梯问题，无论怎么下楼梯，可以发现，最终都会到达第二，此时，你有一大步到达地面和两小步到达地面        那么三楼到达一楼可以分解为：  可以先走一步到达二楼，再通过二楼到达地面 也可以先走两步到达一楼，在通过一楼到达地面  于是，可得递推公式：dp[i] &#x3D; dp[i-1] + dp[i-2] （3） 初始化dp数组12dp[1] = 1;  //一种方案到达地面dp[2] = 2;  //两种方案到达地面  （4）确定遍历顺序​           由递推公式可得,dp[i]依赖于后两个数，所以从后向前递推 完整代码1234567891011121314151617181920class Solution &#123;public:    int climbStairs(int n) &#123;        if(n &lt;= 1) return n; ...</div></div></div></a><a class="pagination-related" href="/2024/12/04/%E9%87%8F%E5%AD%90%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80qiskit/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF/" title="量子线路"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">量子线路</div></div><div class="info-2"><div class="info-item-1">初步认识电路在 Qiskit 中，量子电路由类表示QuantumCircuit。下面是一个量子电路的示例，它生成一个三量子比特的 Greenberger–Horne–Zeilinger (GHZ) 状态，其定义为： ​                                   ∣ψ⟩&#x3D;（∣000⟩+∣111⟩）&#x2F;2∣ ψ ⟩&#x3D;（∣000⟩+∣111⟩ ）&#x2F;2 12345678910111213from qiskit import QuantumCircuitimport matplotlib.pyplot as plt# Create a circuit with a register of three qubitscirc = QuantumCircuit(3)# H gate on qubit 0, putting this qubit in a superposition of |0&gt; + |1&gt;.circ.h(0)# A CX (CNOT) gate on control qubit 0 and target...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/01.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">陈智涛</div><div class="author-info-description">纵使前路茫茫，莫回头，随心荡人间</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%AF%BE"><span class="toc-number">1.</span> <span class="toc-text">第一课</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python-%E4%B8%AD%E7%9A%84%E5%90%91%E9%87%8F%E5%92%8C%E7%9F%A9%E9%98%B5"><span class="toc-number">1.1.</span> <span class="toc-text">Python 中的向量和矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E3%80%81%E6%B5%8B%E9%87%8F%E5%92%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">状态、测量和操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E5%92%8C%E6%98%BE%E7%A4%BA%E7%8A%B6%E6%80%81%E5%90%91%E9%87%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.定义和显示状态向量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E2%80%9CStatevector%E2%80%9D%E6%A8%A1%E6%8B%9F%E6%B5%8B%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.使用“Statevector”模拟测量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-Operator-%E5%92%8C-Statevector-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.使用 Operator 和 Statevector 执行操作&#96;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B1%95%E6%9C%9B%E9%87%8F%E5%AD%90%E7%94%B5%E8%B7%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">4.展望量子电路</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%AF%BE"><span class="toc-number">2.</span> <span class="toc-text">第二课</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.</span> <span class="toc-text">经典信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%9A%84%E7%BB%8F%E5%85%B8%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.通过笛卡尔积的经典状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B0%86%E7%8A%B6%E6%80%81%E8%A1%A8%E7%A4%BA%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.将状态表示为字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A6%82%E7%8E%87%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.3.</span> <span class="toc-text">3.概率状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF%E7%8A%B6%E6%80%81%E9%9B%86"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">排序笛卡尔积状态集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E7%B3%BB%E7%BB%9F%E7%8B%AC%E7%AB%8B"><span class="toc-number">2.1.3.2.</span> <span class="toc-text">两个系统独立</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E5%BC%A0%E9%87%8F%E7%A7%AF"><span class="toc-number">2.1.3.3.</span> <span class="toc-text">向量的张量积</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%88%96%E6%9B%B4%E5%A4%9A%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8B%AC%E7%AB%8B%E6%80%A7%E5%92%8C%E5%BC%A0%E9%87%8F%E7%A7%AF"><span class="toc-number">2.1.3.4.</span> <span class="toc-text">三个或更多系统的独立性和张量积</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E7%8A%B6%E6%80%81%E7%9A%84%E6%B5%8B%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">概率状态的测量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E6%B5%8B%E9%87%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">部分测量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E7%8A%B6%E6%80%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.2.</span> <span class="toc-text">概率状态的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%94%E8%AE%B0"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">笔记</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.3.</span> <span class="toc-text">独立操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E5%BC%A0%E9%87%8F%E7%A7%AF"><span class="toc-number">2.2.4.</span> <span class="toc-text">矩阵的张量积</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF"><span class="toc-number">2.3.</span> <span class="toc-text">量子信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8F%E5%AD%90%E7%8A%B6%E6%80%81"><span class="toc-number">2.3.1.</span> <span class="toc-text">量子状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%87%8F%E5%AD%90%E6%80%81%E5%90%91%E9%87%8F%E7%9A%84%E5%BC%A0%E9%87%8F%E7%A7%AF"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">量子态向量的张量积</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A0%E7%BC%A0%E6%80%81"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">纠缠态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bell-states"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">Bell states</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GHZ-and-W-states"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">GHZ and W states</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Additional-examples"><span class="toc-number">2.3.1.5.</span> <span class="toc-text">Additional examples</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E7%AC%94%E8%AE%B0"><span class="toc-number">2.3.1.5.1.</span> <span class="toc-text">理解笔记</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8F%E5%AD%90%E7%8A%B6%E6%80%81%E7%9A%84%E6%B5%8B%E9%87%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text">量子状态的测量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%89%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.3.</span> <span class="toc-text">酉操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%90%84%E4%B8%AA%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%8B%AC%E7%AB%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8D%95%E5%85%83%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">在各个系统上独立执行的单元操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">交换操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%97%E6%8E%A7%E5%8D%95%E4%B8%80%E8%BF%90%E8%90%A5"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">受控单一运营</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><div class="content"><a class="title" href="/2024/12/30/Java%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/Day01/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%882%EF%BC%89/" title="反转字符串（2）">反转字符串（2）</a><time datetime="2024-12-30T13:36:45.000Z" title="发表于 2024-12-30 21:36:45">2024-12-30</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/12/26/Java%E8%93%9D%E6%A1%A5%E6%9D%AF/dfs%E5%9B%9E%E6%BA%AF/" title="dfs回溯">dfs回溯</a><time datetime="2024-12-26T14:19:29.000Z" title="发表于 2024-12-26 22:19:29">2024-12-26</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/12/25/Java%E8%93%9D%E6%A1%A5%E6%9D%AF/DFS/" title="DFS">DFS</a><time datetime="2024-12-25T14:07:37.000Z" title="发表于 2024-12-25 22:07:37">2024-12-25</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/12/25/Qiskit%E8%AF%BE%E7%A8%8B/SingleSystem/VQE%E6%A1%86%E6%9E%B6/" title="无标题">无标题</a><time datetime="2024-12-25T08:40:20.752Z" title="发表于 2024-12-25 16:40:20">2024-12-25</time></div></div><div class="aside-list-item"><div class="content"><a class="title" href="/2024/12/25/Qiskit%E8%AF%BE%E7%A8%8B/SingleSystem/%E5%8F%98%E5%88%86%E7%BA%BF%E8%B7%AF%E7%90%86%E8%A7%A3/" title="无标题">无标题</a><time datetime="2024-12-25T07:32:25.248Z" title="发表于 2024-12-25 15:32:25">2024-12-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By 陈智涛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>